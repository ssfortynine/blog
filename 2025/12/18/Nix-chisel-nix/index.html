<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 看懂chisel-nix项目中的nix框架设计 · ssfortynine's Blog</title><meta name="description" content="看懂chisel-nix项目中的nix框架设计 - ssfortynine"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/cat.png"><link rel="stylesheet" href="/css/apollodark.css"><link rel="search" type="application/opensearchdescription+xml" href="https://ssfortynine.github.io/blog/atom.xml" title="ssfortynine's Blog"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="ssfortynine's Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/cat.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/ssfortynine" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">看懂chisel-nix项目中的nix框架设计</h1><div class="post-info">Dec 18, 2025</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对 Chisel-nix 项目的 nix 框架的每行代码进行解读，个人参考使用。如果不知道哪行代码是什么意思，查阅使用。</p>
<h2 id="主目录-nix"><a href="#主目录-nix" class="headerlink" title="主目录 nix"></a>主目录 nix</h2><p>主目录下的 <code>flake.nix</code> 主要调用的是 <code>./templates</code> 内的 flake 文件(<code>default.nix</code>) 。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">description</span> = <span class="string">&quot;Chisel Flakes&quot;</span>;  <span class="comment"># 1. Flake 的描述</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">outputs</span> = &#123; self &#125;: &#123;           <span class="comment"># 2. 定义 Flake 的输出</span></span><br><span class="line">    <span class="attr">templates</span> = <span class="built_in">import</span> ./templates; <span class="comment"># 3. 导入模版定义</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>default.nix</code> 文件定义了模板的源文件在哪里，即 <code>./chisel</code> 文件夹里包含了构建 Chisel 项目所需的所有初始文件</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;chisel&quot;</span> = &#123;                        <span class="comment"># 1. 模版的名称</span></span><br><span class="line">    <span class="attr">path</span> = ./chisel;                  <span class="comment"># 2. 模版文件的实际路径</span></span><br><span class="line">    <span class="attr">description</span> = <span class="string">&quot;Basic chisel project setup&quot;</span>; <span class="comment"># 3. 模版的描述</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两段代码允许用户通过一行命令初始化一个 Chisel 项目。即在 <code>README.md</code> 中使用命令即可创建 chisel-nix 项目的模板</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nix flake init -t github:chipsalliance/chisel-nix#chisel</span><br></pre></td></tr></table></figure>

<h2 id="模板内部-nix"><a href="#模板内部-nix" class="headerlink" title="模板内部 nix"></a>模板内部 nix</h2><h3 id="外部-flake-nix"><a href="#外部-flake-nix" class="headerlink" title="外部 flake.nix"></a>外部 <code>flake.nix</code></h3><p>这个 <code>flake.nix</code> 主要配置一个混合语言的开发环境，并使用了 <code>flake-parts</code> 框架来简化配置</p>
<h4 id="核心源数据与输入-inputs"><a href="#核心源数据与输入-inputs" class="headerlink" title="核心源数据与输入 (inputs)"></a>核心源数据与输入 (<code>inputs</code>)</h4><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inputs</span> = &#123;</span><br><span class="line">  nixpkgs.<span class="attr">url</span> = <span class="string">&quot;github:NixOS/nixpkgs/nixos-unstable&quot;</span>; <span class="comment"># 基础包源</span></span><br><span class="line">  <span class="attr">flake-parts</span> = &#123; ... &#125;;   <span class="comment"># 一个用于简化 Flake 编写的模块化框架</span></span><br><span class="line">  <span class="attr">treefmt-nix</span> = &#123; ... &#125;;   <span class="comment"># 用于统一代码格式化工具的配置</span></span><br><span class="line">  zaozi.<span class="attr">url</span> = <span class="string">&quot;github:sequencer/zaozi&quot;</span>; <span class="comment"># 一个Sequencer团队设计的一个新的eDSL语言</span></span><br><span class="line">  mill-ivy-fetcher.<span class="attr">url</span> = <span class="string">&quot;github:Avimitin/mill-ivy-fetcher&quot;</span>; <span class="comment"># 用于帮助 Nix 下载 Scala Mill 构建工具所需的 Maven 依赖</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作用</strong>：定义了项目构建所需的所有外部依赖源</li>
</ul>
<h4 id="Flake-结构-flake-parts"><a href="#Flake-结构-flake-parts" class="headerlink" title="Flake 结构 (flake-parts)"></a>Flake 结构 (<code>flake-parts</code>)</h4><p>使用 <code>flake-parts.lib.mkFlake</code>，这是 <code>flake-parts</code> 库提供的函数，<mark style="background: #FF5582A6;">使用更清晰的结构来编写 Flake，而不需要手动处理每个架构的循环。</mark></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">systems</span> = [ <span class="string">&quot;x86_64-linux&quot;</span> <span class="string">&quot;aarch64-linux&quot;</span> <span class="string">&quot;aarch64-darwin&quot;</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：定义该项目支持的操作系统（Linux 的 x86 和 ARM，以及 macOS 的 Apple Silicon）</li>
</ul>
<h4 id="全局-Overlay-配置"><a href="#全局-Overlay-配置" class="headerlink" title="全局 Overlay 配置"></a>全局 Overlay 配置</h4><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> </span><br><span class="line">	<span class="attr">overlay</span> = <span class="built_in">import</span> ./nix/overlay.nix; <span class="comment"># 导入本地定义的overlay</span></span><br><span class="line"><span class="keyword">in</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">flake.overlays.<span class="attr">defalut</span> = overlay; <span class="comment"># 将本地overlay导出给外部使用</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：<code>overlay</code> 是 Nix 的一种机制，用于拓展或修改 <code>nixpkgs</code>。并将其暴露出去，使得其他 Flake 也可以引用这个项目定义的包</li>
</ul>
<h4 id="系统级配置-perSystem"><a href="#系统级配置-perSystem" class="headerlink" title="系统级配置 (perSystem)"></a>系统级配置 (<code>perSystem</code>)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">perSystem =</span><br><span class="line">        &#123; system, pkgs, ... &#125;:</span><br><span class="line">        &#123; .., &#125;;</span><br></pre></td></tr></table></figure>
<p> 针对每一个 <code>system</code>（架构）生成具体的输出</p>
<h5 id="pkgs-实例"><a href="#pkgs-实例" class="headerlink" title="pkgs 实例"></a><code>pkgs</code> 实例</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_module.args.<span class="attr">pkgs</span> = <span class="built_in">import</span> nixpkgs &#123;</span><br><span class="line">	<span class="keyword">inherit</span> system;</span><br><span class="line">	<span class="attr">overlays</span> = <span class="keyword">with</span> inputs; [</span><br><span class="line">		zaozi.overlays.defalut		<span class="comment"># 导入 zaozi</span></span><br><span class="line">		mill-ivy-fetcher.overlays.defalut <span class="comment"># 引入 Mill 依赖抓取工具</span></span><br><span class="line">		overlay</span><br><span class="line">	];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里使用了标准的 <code>nixpkgs</code>，还叠加了三个 Overlay。在后续，可以直接通过使用 <code>pkgs.zaozi</code> 等</li>
</ul>
<h5 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a>代码格式化</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">treefmt</span> = &#123;</span><br><span class="line">    <span class="attr">projectRootFile</span> = <span class="string">&quot;flake.nix&quot;</span>;</span><br><span class="line">    programs.<span class="attr">scalafmt</span> = &#123;</span><br><span class="line">        <span class="attr">enable</span> = <span class="literal">true</span>;</span><br><span class="line">        <span class="attr">includes</span> = [ <span class="string">&quot;*.mill&quot;</span> ];</span><br><span class="line">    &#125;;</span><br><span class="line">    programs.<span class="attr">nixfmt</span> = &#123;</span><br><span class="line">        <span class="attr">enable</span> = <span class="literal">true</span>;</span><br><span class="line">        <span class="attr">excludes</span> = [ <span class="string">&quot;*/generated.nix&quot;</span> ];</span><br><span class="line">    &#125;;</span><br><span class="line">    programs.rustfmt.<span class="attr">enable</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：配置 <code>nix fmt</code> 命令。运行该命令会自动格式化项目中的 Scala，Nix 和 Rust 代码</li>
</ul>
<h5 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">devShells.<span class="attr">default</span> = <span class="keyword">with</span> pkgs;</span><br><span class="line">    mkShell (</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">inputsFrom</span> = [ gcd.gcd-compiled ];</span><br><span class="line">            <span class="attr">packages</span> = [</span><br><span class="line">                cargo</span><br><span class="line">                rust-analyzer</span><br><span class="line">                nixd</span><br><span class="line">                nvfetcher</span><br><span class="line">            ];</span><br><span class="line">            <span class="attr">RUST_SRC_PATH</span> = <span class="string">&quot;<span class="subst">$&#123;rust.packages.stable.rustPlatform.rustLibSrc&#125;</span>&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        // gcd.tb-dpi-lib.env</span><br><span class="line">        // gcd.gcd-compiled.env</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<ul>
<li>在 overlay 中叠加的 Overlay，可以直接使用 <code>pkgs.gcd</code>，就像使用 <code>nixpkgs</code> 标准库一样</li>
<li><code>inputsFrom</code>: 是一个很方便的功能。它表示“把构建 <code>gcd.gcd-compiled</code> 所需的所有依赖（编译器、库等）都加到这个 Shell 里”</li>
<li><code>// gcd...env</code>: 这里的 &#x2F;&#x2F; 是 Nix 的合并操作符。将 <code>gcd.tb-dpi-lib</code> 和 <code>gcd.gcd-compiled</code> 这两个包所特有的环境配置（比如特定的 <code>CFLAGS</code> 或库路径）合并到了当前的 Shell 环境中。</li>
</ul>
<p>在 nix 中环境变量的设置要在 <code>devShells</code> 进行设置，因为 nix 安装的包是保存在 <code>nix/store/...</code> 中，默认的环境变量设置会找不到包的库</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>利用 Overlay 将外部工具 (Zaozi, Mill) 和本地定义的硬件模块（如 <code>gcd</code>）整合到一起</li>
<li>配置 Scala (chisel) 和 Rust 的混合开发工具链</li>
<li>通过 <code>flake-parts</code> 保证在多个 system 架构上运行</li>
<li>运行 <code>nix develop</code> 时，会得到一个安装好了 Cargo、Rust Analyzer、Scala 构建工具以及所有硬件仿真依赖的终端环境。</li>
</ol>
<h3 id="解析nix-overlay-nix"><a href="#解析nix-overlay-nix" class="headerlink" title="解析nix/overlay.nix"></a>解析<code>nix/overlay.nix</code></h3><h4 id="强制读取环境变量"><a href="#强制读取环境变量" class="headerlink" title="强制读取环境变量"></a>强制读取环境变量</h4><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> </span><br><span class="line">	getEnv&#x27; = </span><br><span class="line">		key:</span><br><span class="line">		<span class="keyword">let</span></span><br><span class="line">			<span class="attr">val</span> = <span class="built_in">builtins</span>.getEnv key:</span><br><span class="line">		<span class="keyword">in</span></span><br><span class="line">		<span class="keyword">if</span> <span class="attr">val</span> == <span class="string">&quot;&quot;</span> <span class="keyword">then</span> <span class="built_in">builtins</span>.<span class="built_in">throw</span> <span class="string">&quot;<span class="subst">$&#123;key&#125;</span> not set or &#x27;--impure&#x27; not applied&quot;</span> <span class="keyword">else</span> val;</span><br><span class="line"><span class="keyword">in</span></span><br></pre></td></tr></table></figure>
<ul>
<li>作用：读取宿主机的环境变量。尝试读取变量 <code>key</code>，如果读取为空直接报错 (throw)，中断构建。通常用于获取商业 EDA 软件的 License 路径 (例如 <code>LM_LICENSE_FILE</code>) 或安装路径。如果没有这些变量，商业工具无法运行，所以必须强制检查。</li>
<li>其他：<code>--impure</code>，要求用户在运行 Nix 命令的时候要加上 <code>--impure</code> 参数</li>
</ul>
<h4 id="Overlay-主体"><a href="#Overlay-主体" class="headerlink" title="Overlay 主体"></a>Overlay 主体</h4><p>Overlay 的标准签名：</p>
<ul>
<li><code>prev</code>：修改前的包集合（通常指官方的 <code>nixpkgs</code> ）</li>
<li><code>final</code>: 修改后的最终包集合</li>
</ul>
<h5 id="逻辑综合工具（espresso）"><a href="#逻辑综合工具（espresso）" class="headerlink" title="逻辑综合工具（espresso）"></a>逻辑综合工具（<code>espresso</code>）</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">espresso</span> = final.callPackage ./pkgs/espresso.nix &#123; &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>引入了一个名为 <code>espresso</code> 的包，定义在 <code>./pkgs/espresso.nix</code> 中。Espresso 是一个经典的启发式逻辑最小化工具，用于数字电路设计的早期阶段</li>
</ul>
<h5 id="构建工具-mill"><a href="#构建工具-mill" class="headerlink" title="构建工具 (mill)"></a>构建工具 (<code>mill</code>)</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mill</span> = </span><br><span class="line">	<span class="keyword">let</span></span><br><span class="line">		<span class="attr">jre</span> = final.jdk21; <span class="comment"># 强制使用 JDK21</span></span><br><span class="line">	<span class="keyword">in</span></span><br><span class="line">	(prev.mill.override &#123; <span class="keyword">inherit</span> jre; &#125;).overrideAttrs <span class="keyword">rec</span> &#123;</span><br><span class="line">		<span class="comment"># 修复了目标解析中的排序 bug</span></span><br><span class="line">    	<span class="attr">version</span> = <span class="string">&quot;0.12.8-1-46e216&quot;</span>;</span><br><span class="line">    	<span class="attr">src</span> = final.fetchurl &#123; ... &#125;;</span><br><span class="line">    	<span class="attr">passthru</span> = &#123; <span class="keyword">inherit</span> jre; &#125;;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>强制使用 <code>jdk21</code> 运行，提供了一个特定的 mill 版本，官方源里的 Mill 可能存在 Bug 导致构建失败，这里提供了一个修复版的 JAR 包</li>
</ul>
<h5 id="商业-EDA-环境封装-vcs-fhs-env，cds-fhs-env"><a href="#商业-EDA-环境封装-vcs-fhs-env，cds-fhs-env" class="headerlink" title="商业 EDA 环境封装 (vcs-fhs-env，cds-fhs-env)"></a>商业 EDA 环境封装 (<code>vcs-fhs-env</code>，<code>cds-fhs-env</code>)</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">vcs-fhs-env</span> = final.callPackage ./pkgs/vcs-fhs-env.nix &#123; <span class="keyword">inherit</span> getEnv&#x27;; &#125;;</span><br><span class="line"><span class="attr">cds-fhs-env</span> = final.callPackage ./pkgs/cds-fhs-env.nix &#123; <span class="keyword">inherit</span> getEnv&#x27;; &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>VCS</strong>: Synopsys VCS (Verilog 仿真器)。</li>
</ul>
<ul>
<li><strong>CDS</strong>: Cadence Design Systems 工具集 (如 Xcelium, Genus 等)。</li>
<li><strong>FHS Env</strong>: 这里的 fhs-env 指 “Filesystem Hierarchy Standard Environment”。<ul>
<li>商业 EDA 软件通常是闭源的二进制文件，依赖传统的 Linux 目录结构（&#x2F;lib, &#x2F;bin 等），而 NixOS 的目录结构非常特殊。</li>
<li>这些包通常使用 buildFHSUserEnv 创建一个虚拟的、符合标准 Linux 结构的沙盒环境，以便运行这些商业软件。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>传入 getEnv’</strong>：把之前定义的读取环境变量函数传进去。这两个包的构建或运行<strong>必须</strong>依赖外部环境变量（ License 服务器地址）</li>
</ul>
<h5 id="本地项目-gcd"><a href="#本地项目-gcd" class="headerlink" title="本地项目 (gcd)"></a>本地项目 (gcd)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcd = final.callPackage ./gcd &#123; &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>说明</strong>：当前项目的主要构建目标，定义在当前目录下的 gcd 文件夹中。</li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>该 nix 的主要特点是为商业工具做了适配</p>
<ul>
<li>同时支持开源工具（Mill, Espresso）和闭源商业工具（Synopsys VCS, Cadence）。</li>
<li>通过 <code>fhs-env</code> 让商业软件可以在 Nix 环境中运行</li>
<li>必须需要宿主机的 License 的配置，通过 <code>impure</code> 构建</li>
</ul>
<h3 id="解析-nix-pkgs-文件夹下"><a href="#解析-nix-pkgs-文件夹下" class="headerlink" title="解析 nix/pkgs 文件夹下"></a>解析 <code>nix/pkgs</code> 文件夹下</h3><p>在 <code>cds-fhs-env.nix</code> 和 <code>vcs-fhs-env.nix</code> 文件夹下<mark style="background: #FF5582A6;">都使用了 Nix FHS 环境</mark>，用于运行 Cadence 公司和 Synopsys 公司的闭源工具。这些工具都是闭源的二进制文件，编译时依赖传统的 Linux 目录结构 (如 <code>/usr/lib</code>, <code>/bin</code>)，无法直接在 NixOS 这种独特文件系统结构下运行。所以需要构建一个虚拟的“标准 Linux 环境”。</p>
<h4 id="锁定依赖源-nixpkgsSrcs-lockedPkgs"><a href="#锁定依赖源-nixpkgsSrcs-lockedPkgs" class="headerlink" title="锁定依赖源 (nixpkgsSrcs &amp; lockedPkgs)"></a>锁定依赖源 (<code>nixpkgsSrcs</code> &amp; <code>lockedPkgs</code>)</h4><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span></span><br><span class="line">  <span class="attr">nixpkgsSrcs</span> = fetchFromGitHub &#123;</span><br><span class="line">    <span class="attr">owner</span> = <span class="string">&quot;NixOS&quot;</span>;</span><br><span class="line">    <span class="attr">repo</span> = <span class="string">&quot;nixpkgs&quot;</span>;</span><br><span class="line">    <span class="attr">rev</span> = <span class="string">&quot;c374d94f1536013ca8e92341b540eba4c22f9c62&quot;</span>; <span class="comment"># 具体的 Commit ID</span></span><br><span class="line">    <span class="attr">hash</span> = <span class="string">&quot;sha256-Z/ELQhrSd7bMzTO8r7NZgi9g5emh+aRKoCdaAv5fiO0=&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="attr">lockedPkgs</span> = <span class="built_in">import</span> nixpkgsSrcs &#123; <span class="attr">system</span> = <span class="string">&quot;x86_64-linux&quot;</span>; &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>没有使用当前系统或 Flake 输入的 <code>nixpkgs</code>，而是使用 <code>fetchFromGithub</code> 下载了一个特定历史版本的 Nixpkgs。商业 EDA 工具（通常比较古老或更新缓慢）对基础库 (如 glibc, libstdc++) 的版本比较敏感。使用最新的库会导致各种“符号未定义”或段错误</li>
<li>明确指定 system &#x3D; “x86_64-linux”，因为这些商业工具通常只发布 Linux x86_64 的二进制包。</li>
</ul>
<h4 id="获取宿主环境信息"><a href="#获取宿主环境信息" class="headerlink" title="获取宿主环境信息"></a>获取宿主环境信息</h4><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jasperHome</span> = getEnv&#x27; <span class="string">&quot;JASPER_HOME&quot;</span>;</span><br><span class="line"><span class="attr">cdsLicenseFile</span> = getEnv&#x27; <span class="string">&quot;CDS_LIC_FILE&quot;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>JASPER_HOME</strong>：Cadence JasperGold 的安装目录。</li>
</ul>
<ul>
<li><strong>CDS_LIC_FILE</strong>：License 文件的路径或服务器地址。</li>
</ul>
<ul>
<li>该 Nix 不负责安装 Cadence 软件，只是负责搭建一个能让安装软件跑起来的沙盒环境</li>
</ul>
<h4 id="构建-FHS-虚拟环境-buildFHSEnv"><a href="#构建-FHS-虚拟环境-buildFHSEnv" class="headerlink" title="构建 FHS 虚拟环境 (buildFHSEnv)"></a>构建 FHS 虚拟环境 (<code>buildFHSEnv</code>)</h4><p>使用 <code>lockedPkgs.buildFHSEnv</code> 创建环境</p>
<h5 id="启动脚本-profile"><a href="#启动脚本-profile" class="headerlink" title="启动脚本 (profile)"></a>启动脚本 (<code>profile</code>)</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">profile</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">  [ ! -e &quot;<span class="subst">$&#123;jasperHome&#125;</span>&quot;  ] &amp;&amp; echo ... &amp;&amp; exit 1</span></span><br><span class="line"><span class="string">  export JASPER_HOME=<span class="subst">$&#123;jasperHome&#125;</span></span></span><br><span class="line"><span class="string">  export CDS_LIC_FILE=<span class="subst">$&#123;cdsLicenseFile&#125;</span></span></span><br><span class="line"><span class="string">  export PATH=$JASPER_HOME/bin:$PATH</span></span><br><span class="line"><span class="string">  # ...</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>检查：进入环境时，先检查 JASPER_HOME 是否存在，不存在则报错退出。</li>
</ul>
<ul>
<li>导出变量：将外部的环境变量透传到虚拟环境中。</li>
</ul>
<ul>
<li>设置 PATH：将 JasperGold 的 bin 目录加入 PATH，这样用户在环境里直接输命令就能运行工具</li>
</ul>
<h5 id="依赖包列表-targetPkgs"><a href="#依赖包列表-targetPkgs" class="headerlink" title="依赖包列表 (targetPkgs)"></a>依赖包列表 (<code>targetPkgs</code>)</h5><p>满足商业二进制程序的动态链接库 (<code>.so</code>) 需求</p>
<ul>
<li>基础库：glib, zlib, util-linux, coreutils-full。</li>
<li>兼容性库：<ul>
<li>libxcrypt-legacy: 旧版加密库。</li>
<li>ncurses5: 很多老软件依赖版本 5，而现代系统通常是版本 6。</li>
</ul>
</li>
<li>图形界面 (GUI)：xorg.libX11, freetype, fontconfig, libGL 等。EDA 工具通常有复杂的图形界面（查看波形等），需要这些 X11 库支持。</li>
<li>特定版本覆盖 (Overrides)：<ul>
<li>libkrb5 (Kerberos): 强制降级到 1.18.2。</li>
<li>gnugrep: 强制降级到 3.1 且跳过测试 (doCheck &#x3D; false)。<br>Cadence 的某些脚本或二进制可能硬编码了对旧版 grep 参数的依赖，或者链接了特定版本的 Kerberos 库。如果不手动降级，工具会崩溃。</li>
</ul>
</li>
</ul>
<h4 id="Espresso"><a href="#Espresso" class="headerlink" title="Espresso"></a>Espresso</h4><p>Espresso 是一个有名的启发式逻辑最小化工具。主要用于将复杂的数字逻辑电路（布尔函数）简化为更精简的形式，从而减少芯片上的门电路数量</p>
<p>该文件从 Chips Alliance 的 GitHub 仓库下载 Espresso 源码，使用 CMake 和 Ninja 将其编译成可执行文件</p>
<h3 id="解析-nix-gcd-文件目录"><a href="#解析-nix-gcd-文件目录" class="headerlink" title="解析 nix/gcd 文件目录"></a>解析 <code>nix/gcd</code> 文件目录</h3><h4 id="defalut-nix-文件"><a href="#defalut-nix-文件" class="headerlink" title="defalut.nix 文件"></a><code>defalut.nix</code> 文件</h4><p>该文件定义整个 GCD 硬件项目的所有构建流水线。将一个硬件项目拆解位多个细粒度的步骤（编译、生成电路图、转 Verilog、仿真、形式验证），并组装成一个依赖图</p>
<p>这段代码使用了 <code>lib.makeScope</code>，在 Nix 中用于<mark style="background: #FF5582A6;">创建可组合软件包集合的工具</mark>。在 <code>scope</code> 中的每一个属性（如 <code>rtl</code>，<code>verilated</code>）都可以通过 <code>scope</code> 相互引用。</p>
<h5 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span></span><br><span class="line">    <span class="attr">designTarget</span> = <span class="string">&quot;GCD&quot;</span>;          <span class="comment"># 设计主体的类名</span></span><br><span class="line">    <span class="attr">tbTarget</span> = <span class="string">&quot;GCDTestBench&quot;</span>;     <span class="comment"># 测试平台的类名</span></span><br><span class="line">    <span class="attr">formalTarget</span> = <span class="string">&quot;GCDFormal&quot;</span>;    <span class="comment"># 形式验证的类名</span></span><br><span class="line">    <span class="attr">dpiLibName</span> = <span class="string">&quot;gcdemu&quot;</span>;         <span class="comment"># DPI 库名称（用于软硬交互）</span></span><br><span class="line">  <span class="keyword">in</span></span><br></pre></td></tr></table></figure>
<p>这里定义了三个不同的<strong>构建目标</strong>。在 Chisel 中，同一个项目可以导出不同的模块（设计本身、带测试激励的模块、带形式验证约束的模块）</p>
<h5 id="RTL-生成流程"><a href="#RTL-生成流程" class="headerlink" title="RTL 生成流程"></a>RTL 生成流程</h5><ul>
<li><strong>gcd-compiled</strong>：调用 mill 将 Scala&#x2F;Chisel 源码编译成 JVM 字节码（.jar）。</li>
<li><strong>elaborate</strong>：运行 Chisel 的 Elaborator，生成电路的中间表示（FIRRTL 或 Low FIRRTL）。</li>
<li><strong>mlirbc</strong>：将电路转换为 MLIR (Multi-Level IR) 字节码。这是现代 CIRCT 编译流程的一部分。</li>
<li><strong>rtl</strong>：调用 firtool 将 MLIR 转换为最终的 SystemVerilog 文件。</li>
</ul>
<h5 id="仿真流程-Simulation-Flow"><a href="#仿真流程-Simulation-Flow" class="headerlink" title="仿真流程 (Simulation Flow)"></a>仿真流程 (Simulation Flow)</h5><p>这部分定义了如何构建用于测试的仿真环境。</p>
<ul>
<li><strong>测试平台编译</strong>：tb-compiled, tb-elaborate, tb-mlirbc，生成流程同上，但针对的是 GCDTestBench。</li>
<li><strong>tb-rtl</strong>：生成测试用的 Verilog。</li>
<li><strong>tb-dpi-lib</strong>：<strong>DPI (Direct Programming Interface)</strong> 是 SystemVerilog 与 C++&#x2F;Rust 交互的接口。这个包构建了用于驱动仿真的软件部分（例如，用 C++ 写的高级验证逻辑）。</li>
</ul>
<h6 id="具体的仿真器实现"><a href="#具体的仿真器实现" class="headerlink" title="具体的仿真器实现"></a>具体的仿真器实现</h6><ul>
<li><p><strong>Verilator (开源仿真)</strong>：将 tb-rtl 和 dpi-lib 结合，使用 Verilator 编译成可执行的仿真程序。verilated-trace 开启了波形记录功能 (enable-trace &#x3D; true)。</p>
</li>
<li><p><strong>VCS (商业仿真 - Synopsys)</strong>：使用 Synopsys VCS 编译仿真程序。</p>
<ul>
<li><strong>参数微调</strong>：<code>sv2023 = false</code> (禁用最新的 SV 标准以兼容工具), vpi &#x3D; true (开启 VPI 接口), timescale (设置时间精度)。</li>
<li><strong>Layer 覆盖</strong>：<code>enable-layers = [ &quot;Verification&quot; ... ]</code>。这是 Chisel 的高级特性，允许在生成 Verilog 时按需包含验证逻辑（如 assert 语句）</li>
</ul>
</li>
</ul>
<h5 id="形式验证流程-Formal-Flow"><a href="#形式验证流程-Formal-Flow" class="headerlink" title="形式验证流程 (Formal Flow)"></a>形式验证流程 (Formal Flow)</h5><p>形式验证不需要跑仿真，而是通过数学方法证明电路的属性。</p>
<ul>
<li><strong>formal-compiled &#x2F; formal-rtl</strong>：针对 GCDFormal 目标生成代码。<ul>
<li><strong>Layers</strong>: 开启了 Assume (假设), Assert (断言), Cover (覆盖率) 等验证专用的层。这些代码在综合成实际芯片时会被删掉，但在验证时至关重要。</li>
</ul>
</li>
<li><strong>jg-fpv(JasperGold Formal Property Verification)</strong>：用于启动 Cadence JasperGold 加载生成的 formal-rtl 进行数学证明。</li>
</ul>
<h5 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tbConfig</span> = <span class="keyword">with</span> <span class="built_in">builtins</span>; fromJSON (readFile ./../../configs/$&#123;tbTarget&#125;.json);</span><br></pre></td></tr></table></figure>
<ul>
<li>读取外部 JSON 配置文件，可能包含测试的具体参数（如测试向量的大小、种子等）</li>
</ul>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>这段代码将硬件设计流程完全的函数式化</p>
<ol>
<li><code>gcd.nix, elaborate.nix, rtl.nix</code> 被多次调用，只是参数不同（Target 不同）</li>
<li>依赖结构清楚</li>
<li>通过 <code>.override</code> 轻松管理“带波形”和“不带波形”的版本，或者“用于个综合的 RTL”和“用于验证的 RTL”，而不需要复制粘贴大量构建脚本</li>
<li>还集成了开源工具和商业工具</li>
</ol>
<h4 id="gcd-nix-文件"><a href="#gcd-nix-文件" class="headerlink" title="gcd.nix 文件"></a><code>gcd.nix</code> 文件</h4><p>使用 mill 构建工具，将 Scala 源码编译成可执行的 JAR 包，并封装成一个可以直接运行”<code>Elaboration</code>“的命令</p>
<h5 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gcdMillDeps</span> = ivy-gather ../dependencies/locks/gcd-lock.nix;</span><br></pre></td></tr></table></figure>
<ul>
<li>Scala 的构建工具 Mill 通常会在运行时去 Maven Central 下载依赖（互联网访问）。Nix 的构建沙盒默认是无网的，所以这里使用 <code>ivy-gather</code> 读取一个锁文件 <code>gcd-lock.nix</code>，预先在 Nix 中把所有 JAR 包下载好，并在构建时伪装成本地仓库提供给 Mill。实现离线构建</li>
</ul>
<h5 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mainClass</span> = <span class="string">&quot;org.chipsalliance.gcd.elaborator.<span class="subst">$&#123;target&#125;</span>Main&quot;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义 Java 的入口类，作为 <code>installPhase</code> 的 <code>makeWrapper</code> 命令中被使用，作为 Java 命令最后一个参数，高速 JVM 运行哪个 <code>main</code> 函数</li>
</ul>
<h5 id="源码过滤"><a href="#源码过滤" class="headerlink" title="源码过滤"></a>源码过滤</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">src</span> = <span class="keyword">with</span> lib.fileset; toSource &#123;</span><br><span class="line">  <span class="attr">root</span> = ./../..;</span><br><span class="line">  <span class="attr">fileset</span> = unions [</span><br><span class="line">    ./../../build.mill</span><br><span class="line">    ./../../common.mill</span><br><span class="line">    ./../../gcd</span><br><span class="line">    ./../../elaborator</span><br><span class="line">  ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>lib.fileset</code> 是 Nix 一种源码过滤方式，只构建真正需要的文件 (<code>build.mill</code>，<code>common.mill</code> 配置文件和 <code>gcd</code>，<code>elaborator</code> 源码目录) 传入构建环境</li>
</ul>
<h5 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">buildPhase</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">  mill -i &#x27;__.assembly&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>__ (通配符)</strong>：告诉 Mill 构建项目中所有模块。</li>
<li><strong>.assembly</strong>：生成 “Fat JAR”（包含所有依赖的大 JAR 包）。</li>
</ul>
<h5 id="安装与封装"><a href="#安装与封装" class="headerlink" title="安装与封装"></a>安装与封装</h5><p>这段 <code>installPhase</code> 的核心任务是：把编译好的 Java JAR 包，变成一个用户可以直接执行的 Linux 命令 (shell 脚本)，同时处理好复杂的依赖关系</p>
<div class="tip">

<p>在 <code>buildPhase</code> 结束时，Mill 只是在临时的构建目录 (<code>out/elaborator/assembly.dest/out.jar</code> ) 里生成了一个 JAR 包。如果没有 <code>installphase</code>，构建结束后，这个临时文件会被删掉。用户得到 JAR 包，每次运行也需要敲 <code>java -cp path/to/jar com.xxx.Main ...</code> 这一长串命令。而且现在的 Chisel 依赖 C++动态库，如果不配置好，Java 根本跑不起来。</p>
</div>

<h6 id="准备存放-JAR-包的目录"><a href="#准备存放-JAR-包的目录" class="headerlink" title="准备存放 JAR 包的目录"></a>准备存放 JAR 包的目录</h6><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $out/share/jave</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$out</code>: 这是 Nix 构建系统的<strong>最终产出路径</strong>（例如 &#x2F;nix&#x2F;store&#x2F;xm1…-gcd）。</li>
<li><code>/share/java</code>: 这是 Linux 的文件系统标准（FHS）。通常把架构无关的 Java 字节码文件（JAR）放在这里</li>
</ul>
<h6 id="处理“确定性”构建"><a href="#处理“确定性”构建" class="headerlink" title="处理“确定性”构建"></a>处理“确定性”构建</h6><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add-determinism -j $NIX_BUILD_CORES out/elaborator/assembly.dest/out.jar</span><br></pre></td></tr></table></figure>
<ul>
<li>JAR 文件本质上是 ZIP 压缩包。ZIP 格式会保存文件被打包时的时间戳。如果时间戳不同，生成的 JAR 文件的哈希值 (SHA 256) 就会变。Nix 极度依赖哈希值来做缓存。如果哈希变了，Nix 就认为这是一个全新的包，导致所有的下游依赖（比如测试、Verilog 生成）都要全部跑一遍，缓存完全失效。</li>
<li>解决方案：<code>add-determinism</code> 是一个工具，会把 JAR 包里所有文件的时间戳强制重置为1970年1月1日。</li>
</ul>
<h6 id="归档-JAR-包"><a href="#归档-JAR-包" class="headerlink" title="归档 JAR 包"></a>归档 JAR 包</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> out/elaborator/assembly.dest/out.jar <span class="variable">$out</span>/share/java/elaborator.jar</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：把处理过时间戳的 JAR 包，从编译目录移动到我们第一步创建的目录里</li>
</ul>
<h6 id="准备可执行命令的目录"><a href="#准备可执行命令的目录" class="headerlink" title="准备可执行命令的目录"></a>准备可执行命令的目录</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$elaborator</span>/bin</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$out</code>: 存放库文件（JAR），给其他软件引用。</li>
<li><code>$elaborator</code>: 存放可执行程序（bin），给用户在终端使用。</li>
</ul>
<h6 id="制作包装器"><a href="#制作包装器" class="headerlink" title="制作包装器"></a>制作包装器</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">makeWrapper $&#123;jdk21&#125;/bin/java $elaborator/bin/elaborator \</span><br><span class="line">  --add-flags &quot;--enable-preview -Djava.library.path=$&#123;mlir-install&#125;/lib:$&#123;circt-install&#125;/lib -cp $out/share/java/elaborator.jar $&#123;mainClass&#125;&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>makeWrapper &lt;源程序&gt; &lt;目标脚本&gt;</code>：这是一个 Nix 提供的工具函数。它不会复制 Java 二进制文件，而是生成一个 Shell 脚本（包装器）。当运行 <code>$elaborator/bin/elaborator</code> 时，它内部实际上是在运行 <code>$&#123;jdk21&#125;/bin/java</code>。</li>
<li><code>--enable-preview</code>：现代 Chisel&#x2F;Scala 3 为了高性能，使用了 Java 21 引入的 <strong>Project Panama (Foreign Function &amp; Memory API)</strong> 来直接调用 C++ 库。这个功能在 Java 21 里还是“预览版”状态，必须显式加上这个参数才能开启，否则报错。</li>
<li><code>-Djava.library.path=$&#123;mlir-install&#125;/lib:$&#123;circt-install&#125;/lib (重中之重)</code>：现在的 Chisel 编译器底层依赖 <strong>CIRCT</strong> 和 <strong>MLIR</strong>（基于 LLVM 的硬件编译器框架）。这些是 <strong>C++</strong> 写的，编译成了 .so (Linux) 动态链接库。Java 虚拟机（JVM）默认不知道去哪里找这些 Nix 仓库里的 .so 文件。如果找不到，就会报 UnsatisfiedLinkError，程序直接崩溃。通过这个参数，显式地告诉 JVM去这几个 Nix 路径下找动态库。这样 Java 代码就能成功调用底层的 C++ 编译器了。</li>
<li><code>-cp $out/share/java/elaborator.jar</code>：指定类路径（Classpath），告诉 Java 去哪里加载我们刚才安装的那个 JAR 包。</li>
<li><code>$&#123;mainClass&#125;</code>：告诉 Java 从哪个类开始运行（例如 org.chipsalliance.gcd.elaborator.GCDMain）。这个变量是由前面的 target 参数决定的。</li>
</ul>
<h5 id="shellHook"><a href="#shellHook" class="headerlink" title="shellHook"></a><code>shellHook</code></h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">shellHook</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">   <span class="subst">$&#123;mill-ivy-env-shell-hook&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   mill -i mill.bsp.BSP/install</span></span><br><span class="line"><span class="string"> &#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行 <code>nix develop</code> 进入开发环境，会自动运行这个脚本。</li>
<li><code>$&#123;mill-ivy-env-shell-hook&#125;</code>: Mill 会默认去用户主目录 <code>~/.cache/coursier/</code> 找依赖。但是在 Nix 的环境中，依赖路径比较特殊所以这个 Hook 会设置一堆的环境变量 (如 <code>COURSIER_CACHE</code> 等)，强制 Mill 去事先下载好的、位于 <code>/nix/store/...</code> 中离线依赖包，即使断网也可以在 Nix Shell 里也能跑编译</li>
<li><code>mill -i mill.bsp.BSP/install</code>：<strong>BSP (Build Server Protocol)</strong>: 这是一个构建工具（Mill）和 IDE（如 IntelliJ IDEA, VS Code + Metals）之间的通信协议。打开一个 Scala 项目，IDE 通常不知道源代码在哪里、依赖在哪里，导致代码全是红线，无法跳转。这行命令会自动生成 .bsp 配置文件。当运行 nix develop 后，再用 VS Code 打开当前目录，Metals 插件会自动识别项目结构</li>
</ul>
<h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">env</span> = &#123;</span><br><span class="line">   <span class="attr">CIRCT_INSTALL_PATH</span> = circt-install;</span><br><span class="line">   <span class="attr">MLIR_INSTALL_PATH</span> = mlir-install;</span><br><span class="line">   <span class="attr">JEXTRACT_INSTALL_PATH</span> = jextract-<span class="number">21</span>;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里的 <code>circt-install</code> 是一个 Derivation (包对象)，会将 PATH 地址替换为它在磁盘上实际绝对路径</li>
</ul>
<h5 id="开发者工具（passthru）"><a href="#开发者工具（passthru）" class="headerlink" title="开发者工具（passthru）"></a>开发者工具（<code>passthru</code>）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">passthru = &#123;</span><br><span class="line">     bump = writeShellApplication &#123;</span><br><span class="line">       name = &quot;bump-gcd-mill-lock&quot;;</span><br><span class="line">       runtimeInputs = [</span><br><span class="line">         mill</span><br><span class="line">         mill-ivy-fetcher</span><br><span class="line">       ];</span><br><span class="line">       text = &#x27;&#x27;</span><br><span class="line">         ivyLocal=&quot;$&#123;dependencies.ivyLocalRepo&#125;&quot;</span><br><span class="line">         export JAVA_TOOL_OPTIONS=&quot;&#x27;&#x27;$&#123;JAVA_TOOL_OPTIONS:-&#125; -Dcoursier.ivy.home=$ivyLocal -Divy.home=$ivyLocal&quot;</span><br><span class="line"></span><br><span class="line">         mif run -p &quot;$&#123;src&#125;&quot; -o ./nix/dependencies/locks/gcd-lock.nix &quot;$@&quot;</span><br><span class="line">       &#x27;&#x27;;</span><br><span class="line">     &#125;;</span><br><span class="line">     inherit target;</span><br><span class="line">     inherit env;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>build.mill</code> 里添加新的 Scala 库依赖，需要运行这个 <code>bump</code> 脚本来更新 Nix 的锁文件。使用命令 <code>nix run .#gcd-compiled.bump</code></p>
<div class="tip">

<p> Nix 要求所有网络下载必须有固定的 hash 值。新加的库会导致之前的 Hash 校验失败，构建报错。运用这个 <code>bump</code> 脚本，利用 <code>mill-ivy-fetcher</code> (<code>mif</code>) 工具可以会读取 <code>src</code>（包含 <code>build.mill</code>），它会解析出所有依赖，然后逐一下载并计算 Hash，最后自动更新 <code>./nix/dependencies/locks/gcd-lock.nix</code> 这个文件</p>
</div>

<h4 id="elaborate-nix"><a href="#elaborate-nix" class="headerlink" title="elaborate.nix"></a><code>elaborate.nix</code></h4><p>运行编译好的 Chisel 程序 (Elaborate)，读取配置参数，生成电路的中间表示 (FIRRTL)，并将其转化为 MLIR 字节码</p>
<h5 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  lib,</span><br><span class="line">  stdenvNoCC, <span class="comment"># 不需要C编译器，这里运行的是编译好的</span></span><br><span class="line">  espresso,</span><br><span class="line">  circt,</span><br><span class="line">  elaborator,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Derivation-定义"><a href="#Derivation-定义" class="headerlink" title="Derivation 定义"></a>Derivation 定义</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">stdenvNoCC.mkDerivation &#123;</span><br><span class="line">  <span class="attr">name</span> = <span class="string">&quot;<span class="subst">$&#123;elaborator.name&#125;</span>-elaborate&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 这一步需要的工具</span></span><br><span class="line">  <span class="attr">nativeBuildInputs</span> = [</span><br><span class="line">    espresso</span><br><span class="line">    circt <span class="comment"># 提供了 firtool 命令</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 源代码指向配置文件夹 (../../configs)</span></span><br><span class="line">  <span class="attr">src</span> = ./../../configs;</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 透传变量，方便下游获取信息</span></span><br><span class="line">  <span class="attr">passthru</span> = &#123;</span><br><span class="line">    <span class="keyword">inherit</span> elaborator;</span><br><span class="line">    <span class="keyword">inherit</span> (elaborator) target; <span class="comment"># 如 &quot;GCD&quot;, &quot;GCDTestBench&quot;</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h5 id="构建脚本"><a href="#构建脚本" class="headerlink" title="构建脚本"></a>构建脚本</h5><p>运行 Chisel Elaborator (生成 FIRRTL)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p elaborate <span class="variable">$out</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;elaborator&#125;</span>/bin/elaborator design \</span><br><span class="line">  --parameter <span class="variable">$src</span>/<span class="variable">$&#123;elaborator.target&#125;</span>.json \</span><br><span class="line">  --target-dir elaborate</span><br></pre></td></tr></table></figure>
<ul>
<li><code>design</code>: Chisel 定义一个子命令，调用上一部生成的 Java 程序，要生成设计</li>
<li><code>--parameter</code>: 读取配置文件</li>
<li><code>--target-dir</code>: 把中间生成的文件保存在临时文件 elaborate 中</li>
</ul>
<p>运行 FIRTOOL 转换为 MLIR</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">firtool elaborate/*.fir \</span><br><span class="line">  --annotation-file elaborate/*.anno.json \</span><br><span class="line">  --emit-bytecode \</span><br><span class="line">  --parse-only \</span><br><span class="line">  -o <span class="variable">$out</span>/<span class="variable">$name</span>.mlirbc</span><br></pre></td></tr></table></figure>
<ul>
<li><code>firtool</code>：CIRCT 核心工具，用来处理 FIRRTL IR</li>
<li><code>elaborate/*.fir</code> &amp; <code>--annotation-file elaborate/*.anno.json</code>：输入刚刚生成的文件</li>
<li><code>--emit-bytecode</code>: <code>firtool</code> 输出的不是 verilog 也不是文本格式的 MLIR，而是 MLIR Bytecode (<code>.mlirbc</code>)，字节码更紧凑，读取速度更快，且能更多的高级结构信息，方便后续步骤处理</li>
<li><code>--parse-only</code>: 告诉编译器只解析别优化别生成 verilog 文件，将 FIRRTL（Chisel 的输出）编译成 MLIR 格式 (CIRCT 输入)。优化和降级工作交给 (<code>rtl.nix</code> 和 <code>mlirbc.nix</code></li>
</ul>
<h4 id="mlirbc-nix"><a href="#mlirbc-nix" class="headerlink" title="mlirbc.nix"></a><code>mlirbc.nix</code></h4><h5 id="构建脚本-1"><a href="#构建脚本-1" class="headerlink" title="构建脚本"></a>构建脚本</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> <span class="variable">$out</span></span><br><span class="line"></span><br><span class="line">firtool <span class="variable">$&#123;elaborate&#125;</span>/<span class="variable">$&#123;elaborate.name&#125;</span>.mlirbc \</span><br><span class="line">  --emit-bytecode \</span><br><span class="line">  -O=debug \</span><br><span class="line">  --preserve-values=named \</span><br><span class="line">  --lowering-options=verifLabels \</span><br><span class="line">  --output-final-mlir=<span class="variable">$out</span>/<span class="variable">$name</span>-lowered.mlirbc</span><br></pre></td></tr></table></figure>
<ul>
<li>输入上一部生成的 MLIR Bytecode 文件</li>
<li>开启调式级别优化，通常编译器有 <code>-O=release</code> 和 <code>-O=debug</code> 两种，前者追求极致的面积和速度，会更改信号名字，后者更看重调试性，尽量保留电路的原始结构，不进行激进的逻辑合并或删除，方便后续看波形或者做形式验证</li>
<li><code>--preserve-value=named</code>: 这个参数强制 firtool 保留源代码中的变量名</li>
<li><code>--lowering-options=verifLabels</code>: 在设计中会存在一些 <code>assert</code> (断言)，<code>assume</code> (假设) ，<code>cover</code>（覆盖率）等验证语句，这个选择控制这些验证结构如何被映射到底层逻辑中，<code>verifLabels</code> 通常意味着保留验证相关的标签信息，这对后续的形式验证比较重要</li>
<li>输出的文件还是 <code>.mlirbc</code> 文件，但是已经通过优化</li>
</ul>
<div class="tip">

<p>将这个步骤单独提取出来，可以让开发者调式中间态，如果生成的 Verilog 有问题，开发者可以检查这个 <code>lowered.mlirbc</code> ，看看是 Chisel 生成错了，还是 firtool 在降级过程中搞错了。</p>
</div>

<h5 id="rtl-nix"><a href="#rtl-nix" class="headerlink" title="rtl.nix"></a><code>rtl.nix</code></h5><p>调用 <code>firtool</code> 将经过优化的 MLIR 中间代码最终翻译成 SystemVerilog 源代码，并生成一份 EDA 工具可用的文件列表 (<code>filelist.f</code>)</p>
<h5 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  mlirbc, <span class="comment"># 上一步产生的优化后的 MLIR</span></span><br><span class="line">  mfcArgs ? [ <span class="comment"># firtool 的参数，默认是发布模式</span></span><br><span class="line">    <span class="string">&quot;-O=release&quot;</span></span><br><span class="line">    <span class="string">&quot;--split-verilog&quot;</span> <span class="comment"># 关键：拆分文件</span></span><br><span class="line">    <span class="string">&quot;--preserve-values=all&quot;</span></span><br><span class="line">    <span class="string">&quot;--lowering-options=verifLabels,omitVersionComment&quot;</span></span><br><span class="line">    <span class="string">&quot;--strip-debug-info&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  enable-layers ? [ ], <span class="comment"># 想要启用的 Chisel Layers</span></span><br><span class="line">&#125;:</span><br></pre></td></tr></table></figure>
<ul>
<li><code>mfcArgs</code> (Modern FIRRTL Compiler Argument):<ul>
<li><code>-O=release</code>: 这里开启发布级优化，通常会进行死代码消除，常量传播等，生成的 Verilog 更精简</li>
<li><code>--split-verilog</code>: 不会将所有代码生成的到一个 <code>.sv</code> 文件中，而是每个模块独立生成一个 <code>.sv</code> 文件</li>
<li><code>--lowering-options=verifLabels,omitVersionComment</code>: 不在文件头部生成 <code>Generated by firtool version x.x.x</code> 的注释，保持文件的哈希稳定性</li>
</ul>
</li>
<li><code>enable-layers</code>：这是 Chisel 的高级特性。你可以把验证逻辑（Assert）、调试探针（Probe）等定义在不同的“层（Layer）”里。默认情况下，firtool 会把这些层的代码生成到<strong>子目录</strong>中。只有当你显式包含这些目录时，这些逻辑才会生效</li>
</ul>
<h5 id="处理-Layer-路径"><a href="#处理-Layer-路径" class="headerlink" title="处理 Layer 路径"></a>处理 Layer 路径</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span></span><br><span class="line">  <span class="attr">processLayer</span> = lib.<span class="built_in">map</span> (str: <span class="string">&quot;./&quot;</span> + lib.replaceStrings [ <span class="string">&quot;.&quot;</span> ] [ <span class="string">&quot;/&quot;</span> ] (lib.toLower str));</span><br><span class="line">  <span class="attr">enableLayersDirs</span> = processLayer enable-layers;</span><br><span class="line"><span class="keyword">in</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Chisel 的层命名通常是 <code>Verification.Assert</code> 这种形式</li>
<li><strong>转换</strong>：firtool 生成文件时，会把点号转换成目录层级，并转为小写。<ul>
<li>输入：[“Verification.Assert”]</li>
<li>转换后：[“.&#x2F;verification&#x2F;assert”]</li>
</ul>
</li>
<li><strong>目的</strong>：计算出我们需要去哪些子目录里找 Verilog 文件。</li>
</ul>
<h5 id="构建脚本-2"><a href="#构建脚本-2" class="headerlink" title="构建脚本"></a>构建脚本</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firtool <span class="variable">$&#123;mlirbc&#125;</span>/<span class="variable">$&#123;mlirbc.name&#125;</span>-lowered.mlirbc -o <span class="variable">$out</span> <span class="variable">$&#123;lib.escapeShellArgs mfcArgs&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>生成 systemverilog</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pushd</span> <span class="variable">$out</span></span><br><span class="line">find . <span class="variable">$&#123;lib.concatStringsSep &quot; &quot; enableLayersDirs&#125;</span> -maxdepth 1 -name <span class="string">&quot;*.sv&quot;</span> -<span class="built_in">type</span> f -<span class="built_in">print</span> &gt; ./filelist.f</span><br><span class="line"><span class="built_in">popd</span></span><br></pre></td></tr></table></figure>
<ul>
<li>生成 <code>filelist.f</code> 文件，解决 EDA 工具 (如 VCS，Verilator, Vivado) 通常不知道该编译哪些文件，需要一个文件清单，也就是 <code>filelist.f</code> 文件<ul>
<li><code>find .</code>: 首先查找根目录下的所有 .sv 文件（这是设计的主体逻辑）。</li>
<li><code>$&#123;enableLayersDirs&#125;</code>:接着查找用户指定的 Layer 目录（例如 verification&#x2F;assert）。如果传入了 enable-layers &#x3D; [“Verification”]，这里就会把 verification 目录下的 .sv 也加进去。 <strong>如果不传</strong>，生成的 Layer 代码虽然在磁盘上，但<strong>不会</strong>出现在 <code>filelist.f</code> 里，仿真器就会忽略它们。这就是<strong>按需启用验证逻辑</strong>的原理。</li>
</ul>
</li>
</ul>
<p>如果想要跑带 Assert 的仿真，直接在 <code>defalut.nix</code> 中调用它传入 <code>enable-layers = [ &quot;Verification.Assert&quot; ]</code> 即可</p>
<h4 id="verilated-nix-文件"><a href="#verilated-nix-文件" class="headerlink" title="verilated.nix 文件"></a><code>verilated.nix</code> 文件</h4><p>使用 Verilator 将生成的 Verilog 代码与 DPI 库链接起来，编译成一个可直接运行的仿真可执行文件</p>
<h5 id="输入参数与依赖"><a href="#输入参数与依赖" class="headerlink" title="输入参数与依赖"></a>输入参数与依赖</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  rtl,        <span class="comment"># 上一步生成的包含 .sv 文件和 filelist.f 的目录</span></span><br><span class="line">  verilator,  <span class="comment"># 仿真工具</span></span><br><span class="line">  dpi-lib,    <span class="comment"># 包含 C++/Rust 测试逻辑的静态库</span></span><br><span class="line">  thread-num ? <span class="number">8</span>, <span class="comment"># 多线程仿真配置，默认 8 线程</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">&#125;:</span><br></pre></td></tr></table></figure>
<ul>
<li><code>rtl</code>：这是 <code>rtl.nix</code> 的输出。Verilator 会去读取里面的 <code>filelist.f</code> 文件</li>
<li><code>dpi-lib</code>：编译好的软件侧逻辑 <code>.a</code> 库文件</li>
</ul>
<h5 id="构建过程-1"><a href="#构建过程-1" class="headerlink" title="构建过程"></a>构建过程</h5><p>构建分为两个主要阶段：Verilating (转译) 和 Compiling (编译)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[nix] running verilator&quot;</span></span><br><span class="line">verilator \</span><br><span class="line">  <span class="variable">$&#123;lib.optionalString dpi-lib.enable-trace &quot;--trace-fst&quot;&#125;</span> \</span><br><span class="line">  --timing \</span><br><span class="line">  --threads <span class="variable">$&#123;toString thread-num&#125;</span> \</span><br><span class="line">  -O1 \</span><br><span class="line">  --main \</span><br><span class="line">  --exe \</span><br><span class="line">  --cc -f filelist.f --top <span class="variable">$&#123;rtl.target&#125;</span> <span class="variable">$&#123;dpi-lib&#125;</span>/lib/<span class="variable">$&#123;dpi-lib.libOutName&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>--trace-fst</code>：支持 FST 格式波形</li>
<li><code>--threads</code>：开启多线程仿真</li>
<li><code>--main</code>：Verilator 会自动生成 C++的 <code>main()</code> 函数。以前需要手写，现在可以自动处理初始化、运行循环和结束清理</li>
<li><code>--exe --cc</code>：编译成可执行文件</li>
<li><code>$&#123;dpi-lib&#125;/lib/...</code>：这里把软件侧的 DPI 静态库路径传给 Verilator，让它生成的 Makefile 能够链接这个库<br>这一步运行之后，会在 <code>obj_dir</code> 目录下生成一大堆 <code>.cpp</code>, <code>.h</code> 和 <code>.mk</code>（Makefile）文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[nix] building verilated C lib&quot;</span></span><br><span class="line"><span class="comment"># ... 备份源码 ...</span></span><br><span class="line"><span class="built_in">cd</span> obj_dir</span><br><span class="line">make -j <span class="string">&quot;<span class="variable">$NIX_BUILD_CORES</span>&quot;</span> -f <span class="variable">$&#123;vName&#125;</span>.mk <span class="variable">$&#123;vName&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>调用 GCC&#x2F;Clang 编译刚刚生成的 C++代码，生成最终的二进制文件</li>
</ul>
<h5 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nix fortify hardening add `-O2` gcc flag,</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># `-O2` will make gcc build time in verilating extremely long</span></span><br><span class="line"><span class="attr">hardeningDisable</span> = [ <span class="string">&quot;fortify&quot;</span> ];</span><br></pre></td></tr></table></figure>
<ul>
<li>Nixpkgs 为了安全，会自动给 GCC 加上 <code>_FORTIFY_SOURCE</code> 和 <code>-O2</code> 优化标志</li>
<li>Verilator 生成的 C++代码量巨大，如果使用这些参数会导致编译时间巨长，而运行时性能不明显，因为 Verilator 已经在代码级做过优化，所以禁用 <code>fortify</code>，让编译速度回归正常</li>
</ul>
<h4 id="vcs-nix-文件"><a href="#vcs-nix-文件" class="headerlink" title="vcs.nix 文件"></a><code>vcs.nix</code> 文件</h4><p>与 <code>verilated.nix</code> 文件类似，但是 vcs 是商业闭源软件，且依赖 FlexLM 许可证，这段代码解决了一些沙盒逃逸、许可证验证以及闭源库链接等</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stdenv.mkDerivation (finalAttr: &#123;</span><br><span class="line">  <span class="attr">name</span> = <span class="string">&quot;vcs&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 1. 禁用沙盒 (Sandbox Relaxed)</span></span><br><span class="line">  <span class="attr">__noChroot</span> = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 2. 禁用 ELF 修复</span></span><br><span class="line">  <span class="attr">dontPatchELF</span> = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>_noChroot = true</code> (impure 构建)：Nix 的构建默认是在严格隔离的沙盒中进行的（无网络、无法访问 <code>/usr</code> 等）。但 VCS 在编译的时候需要连接 License Server 检查许可证。如果关在沙盒里会报错。</li>
<li><code>dontPatchELF = true</code>：商业软件通常有复杂的内部依赖或完整性依赖，修改 ELF 头可能会导致程序损坏或 License 校验失败。这里选择不修改，而是依赖 FHS 环境来运行</li>
</ul>
<h5 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">buildPhase = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="comment"># 1. 准备环境</span></span><br><span class="line">  fhsBash=<span class="variable">$&#123;vcs-fhs-env&#125;</span>/bin/vcs-fhs-env</span><br><span class="line">  <span class="comment"># 获取 Verdi 的安装路径（用于波形支持）</span></span><br><span class="line">  VERDI_HOME=$(<span class="string">&quot;<span class="variable">$fhsBash</span>&quot;</span> -c <span class="string">&quot;printenv VERDI_HOME&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 2. 在 FHS 环境中运行 VCS</span></span><br><span class="line">  <span class="string">&quot;<span class="variable">$fhsBash</span>&quot;</span> vcs \</span><br><span class="line">    -sverilog -full64 -timescale=1ns/1ps \</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 链接 Verdi/Novas 库 (生成 FSDB 波形必须)</span></span><br><span class="line">    -P <span class="variable">$VERDI_HOME</span>/share/PLI/VCS/LINUX64/novas.tab <span class="variable">$VERDI_HOME</span>/share/PLI/VCS/LINUX64/pli.a \</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4. 调试选项 (Verdi KDB 支持)</span></span><br><span class="line">    <span class="variable">$&#123;lib.optionalString dpi-lib.enable-trace &#x27;&#x27;</span></span><br><span class="line"><span class="variable">      -debug_access+pp+dmptf+thread \</span></span><br><span class="line"><span class="variable">      -kdb=common_elab,hgldd_all \</span></span><br><span class="line"><span class="variable">      -assert enable_diag &#x27;&#x27;&#125;</span> \</span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 5. 代码覆盖率 (Coverage)</span></span><br><span class="line">    <span class="variable">$&#123;lib.optionalString enableCover &#x27;&#x27;</span></span><br><span class="line"><span class="variable">      -cm line+cond+fsm+tgl+branch+assert \</span></span><br><span class="line"><span class="variable">      -cm_dir <span class="variable">$&#123;coverageName&#125;</span> &#x27;&#x27;&#125;</span> \</span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 6. 输入文件</span></span><br><span class="line">    -file filelist.f \</span><br><span class="line">    <span class="variable">$&#123;dpi-lib&#125;</span>/lib/<span class="variable">$&#123;dpi-lib.libOutName&#125;</span> \</span><br><span class="line">    -o <span class="variable">$&#123;binName&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>Verdi 集成 (<code>-P novas.tab pli.a</code>)<ul>
<li>VCS 本身生成波形能力较弱 (VCD 格式很大)。通常需要 Verdi 配合使用，生成压缩率极高的 FSDB 格式。这需要链接 Verdi 提供的 PLI（programming Language Interface）库。代码首先动态获取 <code>VERDI_HOME</code>，然后通过 <code>-p</code> 参数把这些闭源参数库链接进仿真库中</li>
</ul>
</li>
<li>调试增强（<code>-kdb</code>）：生成 Knowledge Database, 这允许 Verdi 可以对源码进行交互式调试（查看驱动、负载、回溯信号）<ul>
<li><code>-kdb=common_elab,hgldd_all</code>：使 Verdi 看懂源码和层级结构，且不重复编译</li>
<li><code>-debug_access+pp+dmptf+thread</code>：使其能 dump 波形，并保证多线程仿真的稳定，且不牺牲太多速度</li>
<li><code>-assert enable_diag</code>：使其能看懂断言为什么报错</li>
</ul>
</li>
<li>覆盖率：如果开启，vcs 会在编译时插入计时器，统计代码覆盖率（行覆盖、条件覆盖、状态机覆盖等）结果存入 <code>.vdb</code> 目录</li>
</ul>
<div class="tip">

<ul>
<li>SystemVerilog 的DPI-C 用例和介绍： <a target="_blank" rel="noopener" href="https://jishuzhan.net/article/1831637011975376898">https://jishuzhan.net/article/1831637011975376898</a></li>
<li>Verdi 知识数据库 (KDB) 是其特有的数据库，用于保存一个设计的相关数据，通过使用 VCS 时添加的选项，设计人员可以很方便的生成 KDB</div></li>
</ul>
<h5 id="安装与封装-1"><a href="#安装与封装-1" class="headerlink" title="安装与封装"></a>安装与封装</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">installPhase = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="comment"># ... 复制二进制文件和数据库目录 (.daidir) ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 生成包装脚本</span></span><br><span class="line">  substitute <span class="variable">$&#123;./scripts/vcs-wrapper.sh&#125;</span> <span class="variable">$out</span>/bin/<span class="variable">$&#123;binName&#125;</span> \</span><br><span class="line">    --subst-var-by vcsSimBin <span class="string">&quot;<span class="variable">$out</span>/lib/<span class="variable">$&#123;binName&#125;</span>&quot;</span> \</span><br><span class="line">    --subst-var-by vcsFhsEnv <span class="string">&quot;<span class="variable">$&#123;vcs-fhs-env&#125;</span>/bin/vcs-fhs-env&quot;</span> \</span><br><span class="line">    <span class="comment"># ... 其他变量替换 ...</span></span><br><span class="line">    </span><br><span class="line">  <span class="built_in">chmod</span> +x <span class="variable">$out</span>/bin/<span class="variable">$&#123;binName&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>vcs 编译出的二进制文件 (<code>simv</code> 或 <code>gcd-vcs-simulator</code>) 不能直接运行，它依赖特定的动态库（<code>.so</code> 这些库位于 VCS 的安装目录下)，辅助文件目录 (<code>.daidir</code>) 以及 License 环境变量，所以编写了一个模板脚本 <code>vcs-wrapper.sh</code>，在安装时通过 <code>substitute</code> 将具体路径填进去</li>
</ul>
<h6 id="vcs-wrapper-sh-脚本"><a href="#vcs-wrapper-sh-脚本" class="headerlink" title="vcs-wrapper.sh 脚本"></a><code>vcs-wrapper.sh</code> 脚本</h6><p>在 <code>vcs.nix</code> 的 <code>installPhase</code> 中，使用了 <code>substitute</code> 命令处理这个脚本。它的主要作用是<strong>解决 Nix Store 的“只读”特性与商业 EDA 软件（VCS）运行时需要“写”权限之间的冲突</strong>，并提供规范化的仿真运行环境管理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!@shell@</span></span><br><span class="line"></span><br><span class="line">_EXTRA_ARGS=<span class="string">&quot;<span class="variable">$@</span>&quot;</span> <span class="comment"># 捕获用户传入的额外参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Nix 在构建时会替换 @...@ 之间的变量</span></span><br><span class="line">_LIB=@lib@</span><br><span class="line">_DATE_BIN=@dateBin@</span><br><span class="line">_VCS_SIM_BIN=@vcsSimBin@       <span class="comment"># VCS 编译出的二进制文件路径 (在 /nix/store 中)</span></span><br><span class="line">_VCS_SIM_DAIDIR=@vcsSimDaidir@ <span class="comment"># VCS 生成的辅助数据目录 (在 /nix/store 中)</span></span><br><span class="line">_VCS_FHS_ENV=@vcsFhsEnv@       <span class="comment"># FHS 虚拟环境启动脚本</span></span><br><span class="line">_VCS_COV_DIR=@vcsCovDir@       <span class="comment"># 覆盖率数据库目录名 (如果开启的话)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这些 <code>@变量@</code> 在 vcs.nix 的 installPhase 中被替换成了实际的绝对路径（指向 <code>/nix/store/...</code>）。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_NOW=$(<span class="string">&quot;<span class="variable">$_DATE_BIN</span>&quot;</span> <span class="string">&quot;+%Y-%m-%d-%H-%M-%S&quot;</span>)</span><br><span class="line"><span class="comment"># 如果用户没设 GCD_SIM_RESULT_DIR，默认用当前目录下的 gcd-sim-result</span></span><br><span class="line">_GCD_SIM_RESULT_DIR=<span class="variable">$&#123;GCD_SIM_RESULT_DIR:-&quot;gcd-sim-result&quot;&#125;</span></span><br><span class="line">_CURRENT=<span class="string">&quot;<span class="variable">$_GCD_SIM_RESULT_DIR</span>&quot;</span>/all/<span class="string">&quot;<span class="variable">$_NOW</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$_CURRENT</span>&quot;</span></span><br><span class="line"><span class="comment"># 更新 &quot;result&quot; 软链接，始终指向最新的一次运行</span></span><br><span class="line"><span class="built_in">ln</span> -sfn <span class="string">&quot;all/<span class="variable">$_NOW</span>&quot;</span> <span class="string">&quot;<span class="variable">$_GCD_SIM_RESULT_DIR</span>/result&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>每次运行的时候都会基于时间戳创建一个新的文件夹，防止新的仿真覆盖旧的仿真，方便回溯历史结果</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> <span class="string">&quot;<span class="variable">$_VCS_SIM_BIN</span>&quot;</span> <span class="string">&quot;<span class="variable">$_CURRENT</span>/&quot;</span></span><br><span class="line"><span class="built_in">cp</span> -r <span class="string">&quot;<span class="variable">$_VCS_SIM_DAIDIR</span>&quot;</span> <span class="string">&quot;<span class="variable">$_CURRENT</span>/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$_VCS_COV_DIR</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">cp</span> -vr <span class="string">&quot;<span class="variable">$_LIB</span>/<span class="variable">$_VCS_COV_DIR</span>&quot;</span> <span class="string">&quot;<span class="variable">$_CURRENT</span>/&quot;</span></span><br><span class="line">  _CM_ARG=<span class="string">&quot;-cm assert -cm_dir ./<span class="variable">$_VCS_COV_DIR</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> -R +w <span class="string">&quot;<span class="variable">$_CURRENT</span>&quot;</span></span><br><span class="line"><span class="built_in">pushd</span> <span class="string">&quot;<span class="variable">$_CURRENT</span>&quot;</span> &gt;/dev/null</span><br></pre></td></tr></table></figure>
<ul>
<li><code>_VCS_SIM_BIN</code> 和 <code>_VCS_SIM_DAIDIR</code> 原本位于 Nix Store 中，那是<strong>只读文件系统</strong>。VCS 的仿真程序 (<code>simv</code>) 在运行时，往往需要往自己的目录下写 Lock 文件，或者更新 <code>.daidir</code> 里的状态，甚至覆盖率数据库也需要被写入。如果在 Nix Store 原地运行，程序会因“Permission denied”崩溃。<ul>
<li>把二进制文件和依赖目录复制到用户可写的 <code>_CURRENT</code> 目录。</li>
</ul>
<ul>
<li><code>chmod -R +w</code>: 赋予写权限（从 Nix Store 拷出来的文件默认是只读的）。</li>
<li><code>pushd</code>: 切换到这个新目录，确保产生的波形文件 (.fsdb) 和日志都在这个文件夹里，不污染用户的工作</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_emu_name=$(<span class="built_in">basename</span> <span class="string">&quot;<span class="variable">$_VCS_SIM_BIN</span>&quot;</span>)</span><br><span class="line">_daidir=$(<span class="built_in">basename</span> <span class="string">&quot;<span class="variable">$_VCS_SIM_DAIDIR</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置动态库路径，确保 simv 能找到伴生的 .so 文件</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="string">&quot;<span class="variable">$PWD</span>/<span class="variable">$_daidir</span>:<span class="variable">$LD_LIBRARY_PATH</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 核心执行语句</span></span><br><span class="line"><span class="string">&quot;<span class="variable">$_VCS_FHS_ENV</span>&quot;</span> -c <span class="string">&quot;./<span class="variable">$_emu_name</span> <span class="variable">$_CM_ARG</span> <span class="variable">$_EXTRA_ARGS</span>&quot;</span> &amp;&gt; &gt;(<span class="built_in">tee</span> ./vcs-emu-journal.log)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>LD_LIBRARY_PATH</code>: VCS 编译出的程序往往依赖同目录下 <code>.daidir</code> 里的共享库，需要显式指定。</li>
<li><code>$_VCS_FHS_ENV -c ...</code>:<ul>
<li>这是最关键的一步。它调用 <code>vcs-fhs-env</code>，<strong>创建一个虚拟的 FHS 环境</strong>（有 &#x2F;lib, &#x2F;bin 等标准目录）。</li>
<li>然后在那个虚拟环境里，执行刚才复制过来的仿真程序 <code>./simv</code></li>
</ul>
</li>
<li><code>tee</code>: 将屏幕输出同时保存到 <code>vcs-emu-journal.log</code> 文件中，方便后续查看日志。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成覆盖率报告</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$_VCS_COV_DIR</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="string">&quot;<span class="variable">$_VCS_FHS_ENV</span>&quot;</span> -c <span class="string">&quot;urg -dir &quot;</span>./<span class="variable">$_VCS_COV_DIR</span><span class="string">&quot; -format text&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 节省空间模式</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="variable">$&#123;DATA_ONLY:-0&#125;</span>)); <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">rm</span> -f <span class="string">&quot;./<span class="variable">$_emu_name</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;VCS emulator finished, result saved in <span class="variable">$_GCD_SIM_RESULT_DIR</span>/result&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>urg (Unified Report Generator)</strong>: 如果开启了覆盖率，仿真结束后调用 Synopsys 的工具生成可读的文本报告。</li>
<li><strong>DATA_ONLY</strong>:<ul>
<li>这是一个环境变量开关。</li>
<li>如果设置为 1，仿真跑完后会<strong>删除</strong>那个巨大的仿真二进制文件 (simv 往往很大)。</li>
<li>在 CI&#x2F;CD 中跑成百上千个测试 case 时，我们只关心 Log 和波形，保留几百个同样的二进制文件会把磁盘撑爆。</li>
</ul>
</li>
</ul>
<h5 id="Passthru"><a href="#Passthru" class="headerlink" title="Passthru"></a>Passthru</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">passthru</span> = &#123;</span><br><span class="line">  <span class="keyword">inherit</span> (dpi-lib) enable-trace;</span><br><span class="line">  <span class="keyword">inherit</span> vcs-fhs-env;</span><br><span class="line">  <span class="keyword">inherit</span> dpi-lib;</span><br><span class="line">  <span class="keyword">inherit</span> rtl;</span><br><span class="line"></span><br><span class="line">  tests.<span class="attr">simple-sim</span> = runCommand <span class="string">&quot;<span class="subst">$&#123;binName&#125;</span>-test&quot;</span> &#123; <span class="attr">__noChroot</span> = <span class="literal">true</span>; &#125; <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">    export GCD_SIM_RESULT_DIR=&quot;$(mktemp -d)&quot;</span></span><br><span class="line"><span class="string">    export DATA_ONLY=1</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;finalAttr.finalPackage&#125;</span>/bin/<span class="subst">$&#123;binName&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mkdir -p &quot;$out&quot;</span></span><br><span class="line"><span class="string">    cp -vr &quot;$GCD_SIM_RESULT_DIR&quot;/result/* &quot;$out/&quot;</span></span><br><span class="line"><span class="string">  &#x27;&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>读取 <code>dpi-lib</code> 是否开启了波形记录功能，把运行 vcs 的 FHS 环境暴露出来，以及将构建输入的 C++库 (<code>dpi-lib</code>) 以及 SystemVerilog 源码挂载出来</li>
<li>这里设计了一个冒烟测试，当运行 <code>nix build .#vcs.tests.simple-sim</code> 时，Nix 首先会确保仿真器构建完成，然后立即运行这个测试，如果测试失败，构建流程就会报错。<ul>
<li><code>runCommand</code> 用来运行一段 Shell 脚本来生成一个输出，并且在测试环境中也要在 impure</li>
<li><code>export DATA_ONLY=1</code>：传递给 C++ benchmark 的环境变量，告诉仿真器，只跑数据对比，不要生成波形文件，这样仿真跑的快，不占空间</li>
<li><code>$&#123;finalAttr.finalPackage&#125;/bin/$&#123;binName&#125;</code>：就是再调用仿真器，<code>finalAttr.finalPackage</code> 是 <code>stdenv.mkDerivation</code> 的 <code>finalAttr</code> 模式，引用的是最终生成的包</li>
</ul>
</li>
<li>最终文件保存在 <code>$out</code> 中</li>
</ul>
<h4 id="jg-fpv-nix-文件"><a href="#jg-fpv-nix-文件" class="headerlink" title="jg-fpv.nix 文件"></a><code>jg-fpv.nix</code> 文件</h4><p>这个文件定义了使用 Cadence JasperGold 进行形式化验证的构建，形式化验证不依赖测试向量，而是使用数学方法穷举证明电路的属性是否永远成立</p>
<h5 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">buildPhase = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  runHook preBuild</span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;[nix] running Jasper&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 1. 准备运行环境 wrapper</span></span><br><span class="line">  fhsBash=<span class="variable">$&#123;cds-fhs-env&#125;</span>/bin/cds-fhs-env</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 2. 运行 JasperGold</span></span><br><span class="line">  <span class="string">&quot;<span class="variable">$fhsBash</span>&quot;</span> -c <span class="string">&quot;jg -batch <span class="variable">$&#123;./scripts/FPV.tcl&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">  runHook postBuild</span><br><span class="line"><span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>jg -batch</code>：以批处理模式启动 JasperGold</li>
<li><code>$&#123;./scripts/FPV.tcl&#125;</code>: 控制 JasperGold 行为的核心 <strong>Tcl 脚本</strong>。</li>
</ul>
<h6 id="FPV-tcl-文件"><a href="#FPV-tcl-文件" class="headerlink" title="FPV.tcl 文件"></a><code>FPV.tcl</code> 文件</h6><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Analyze source files and property files</span></span><br><span class="line"><span class="keyword">set</span> fd [<span class="keyword">open</span> ./filelist.f r]</span><br><span class="line"><span class="keyword">if</span> &#123;<span class="variable">$fd</span> &lt; <span class="number">0</span>&#125; &#123;</span><br><span class="line">  <span class="keyword">error</span> <span class="string">&quot;File open failed!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">set</span> filelist [<span class="keyword">split</span> [<span class="keyword">read</span> <span class="variable">$fd</span>] <span class="string">&quot;\n&quot;</span>]</span><br><span class="line"><span class="keyword">close</span> <span class="variable">$fd</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">foreach</span> <span class="keyword">file</span> <span class="variable">$filelist</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> &#123;[<span class="keyword">string</span> length <span class="variable">$file</span>]&#125; &#123;</span><br><span class="line">    analyze -sv12 \ <span class="variable">$file</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>读取 filelist.f</strong>：这个文件是由前面的 rtl.nix 生成的，包含了所有的 SystemVerilog 源码路径。</li>
<li><code>analyze -sv12</code>：这是 JasperGold 的核心命令之一<ul>
<li>它负责<strong>读取并解析</strong>代码。</li>
<li><code>-sv12</code>：指定使用 <strong>SystemVerilog 2012</strong> 标准（支持高级断言语法）。</li>
</ul>
</li>
<li>这段 Tcl 脚本通过读取文件列表，避免了手动一行行输入 <code>analyze file1.sv</code>，使得脚本可以适配任何设计。</li>
</ul>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Elaborate design and properties</span></span><br><span class="line">elaborate</span><br></pre></td></tr></table></figure>
<ul>
<li>建立设计层级结构。在 analyze 只是检查语法后，elaborate 会真正地把各个模块连接起来，解析参数（Parameters），并将其转化为 JasperGold 内部的逻辑网表。它是验证开始前的最后准备。</li>
</ul>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set up Clocks and Resets</span></span><br><span class="line"><span class="keyword">clock</span> <span class="keyword">clock</span></span><br><span class="line">reset reset</span><br></pre></td></tr></table></figure>
<ul>
<li>动态仿真不同，形式验证工具不会自动产生波形。你必须告诉它：<ul>
<li><strong>clock clock</strong>：告诉工具，“clock 这个信号是时钟”。工具会自动处理它的翻转。</li>
<li><strong>reset reset</strong>：告诉工具，“reset 这个信号是复位”。工具会在证明开始时先断言复位信号，让电路进入已知状态，然后再释放复位开始证明。</li>
</ul>
</li>
<li>这里的信号名 clock 和 reset 是硬编码的。如果你的顶层信号叫 <code>clk</code> 或 <code>rst_n</code>，这里需要修改。</li>
</ul>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_design_info</span><br></pre></td></tr></table></figure>
<ul>
<li>在日志中打印设计的统计信息（如寄存器数量、逻辑门数量、输入输出端口数）。</li>
</ul>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Prove properties</span></span><br><span class="line"><span class="comment"># 1st pass: Quick validation of properties with default engines</span></span><br><span class="line">set_max_trace_length <span class="number">100</span></span><br><span class="line">prove -all</span><br></pre></td></tr></table></figure>
<ul>
<li><code>set_max_trace_length 100</code>：<ul>
<li>设置证明的最大深度（周期数）。</li>
<li><strong>含义</strong>：告诉求解器，“如果在 100 个时钟周期内找不到反例（Bug），就暂时先停下”。这通常用于快速扫描。对于深层逻辑 Bug，可能需要更大的深度或无限制。</li>
</ul>
</li>
<li><code>prove -all</code>：<ul>
<li><strong>核心命令</strong>。启动多个数学求解引擎，尝试证明代码中所有的 assert（断言）永远为真，或者找到一个反例（Counter-Example）。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">report -file report.txt</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：将证明结果（Proven &#x2F; Falsified &#x2F; Undetermined）写入 <code>report.txt</code> 文件。</li>
</ul>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> failed_properties [get_property_list -include &#123;status &#123;cex unreachable&#125;&#125;]</span><br><span class="line"><span class="keyword">set</span> length [<span class="keyword">llength</span> <span class="variable">$failed_properties</span>]</span><br><span class="line"><span class="keyword">if</span> &#123; <span class="variable">$length</span> &gt; <span class="number">0</span> &#125; &#123;</span><br><span class="line">  <span class="keyword">puts</span> <span class="string">&quot;There are $length failed properties!&quot;</span></span><br><span class="line">&#125; else &#123;</span><br><span class="line">  <span class="keyword">puts</span> <span class="string">&quot;All properties passed!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入失败数量到文件</span></span><br><span class="line"><span class="keyword">set</span> failed_num [<span class="keyword">open</span> failed_num w]</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$failed_num</span> <span class="string">&quot;$length&quot;</span></span><br><span class="line"><span class="keyword">close</span> <span class="variable">$failed_num</span></span><br><span class="line"><span class="keyword">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>get_property_list ...</code>：向工具查询所有状态为 <code>cex</code> (Counter-Example，即证明失败) 或 <code>unreachable</code> 的属性。</li>
<li><code>puts $failed_num &quot;$length&quot;</code>：<ul>
<li>将失败的属性数量写入名为 <code>failed_num</code> 的文件。</li>
<li><strong>与 Nix 的配合</strong>：在 <code>jg-fpv.nix</code> 的 <code>installPhase</code> 中，这个文件会被复制出来。外部的 CI 系统可以通过检查这个文件的内容（是否为 0）来决定这一步构建是成功还是失败。</li>
</ul>
</li>
<li><code>exit 0</code>：退出 JasperGold。</li>
</ul>
<h5 id="产物保存"><a href="#产物保存" class="headerlink" title="产物保存"></a>产物保存</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">installPhase = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="variable">$out</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cp</span> report.txt <span class="variable">$out</span></span><br><span class="line">  <span class="built_in">cp</span> failed_num <span class="variable">$out</span></span><br><span class="line">  <span class="built_in">cp</span> -r jgproject <span class="variable">$out</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>report.txt</strong>: 验证的文本报告，包含哪些属性证明成功（Proven），哪些失败（Falsified），以及耗时等信息。</li>
<li><strong>failed_num</strong>:<ul>
<li>推测 Tcl 脚本会统计证明失败的属性数量，并写入这个文件。</li>
<li><strong>用途</strong>：CI&#x2F;CD 流水线可以读取这个文件。如果里面的数字大于 0，就标记构建失败，并发送报警。</li>
</ul>
</li>
<li><strong>jgproject</strong>:<ul>
<li>这是 JasperGold 生成的<strong>工程数据库文件夹</strong>。</li>
<li><strong>重要性</strong>：如果验证失败（发现了 Bug），JasperGold 会生成一个反例（Counter-example）波形并存在这里。开发者可以将这个文件夹下载到本地，用图形界面的 JasperGold 打开，回放那个导致 Bug 的波形。</li>
</ul>
</li>
</ul>
<h4 id="dpi-lib-nix-文件"><a href="#dpi-lib-nix-文件" class="headerlink" title="dpi-lib.nix 文件"></a><code>dpi-lib.nix</code> 文件</h4><p>这个文件构建了一个基于Rust 语言的 SystemVerilog DPI（Direct Programming Interface）静态库。这段代码负责把 Rust 写的测试逻辑编译成一个 <code>.a</code>（静态链接库）文件，供后续仿真器链接使用</p>
<h5 id="函数参数与配置"><a href="#函数参数与配置" class="headerlink" title="函数参数与配置"></a>函数参数与配置</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  lib,</span><br><span class="line">  rustPlatform, <span class="comment"># Nix 的 Rust 构建基础设施</span></span><br><span class="line">  tbConfig,     <span class="comment"># 从 JSON 读取的测试平台配置 (如位宽、超时时间)</span></span><br><span class="line">  dpiLibName,   <span class="comment"># Rust 项目的目录名 (例如 &quot;gcdemu&quot;)</span></span><br><span class="line">  sv2023 ? <span class="literal">true</span>,    <span class="comment"># 是否开启 SystemVerilog 2023 标准支持</span></span><br><span class="line">  vpi ? <span class="literal">false</span>,      <span class="comment"># 是否开启 VPI (Verilog Procedural Interface)</span></span><br><span class="line">  enable-trace ? <span class="literal">false</span>, <span class="comment"># 是否开启波形记录功能</span></span><br><span class="line">  timescale ? <span class="number">1</span>,    <span class="comment"># 时钟周期缩放比例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用不同参数适配仿真器的不同需求</li>
</ul>
<h5 id="Rust-包构建"><a href="#Rust-包构建" class="headerlink" title="Rust 包构建"></a>Rust 包构建</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rustPlatform.buildRustPackage <span class="keyword">rec</span> &#123;</span><br><span class="line">  <span class="attr">name</span> = <span class="string">&quot;dpi-lib&quot;</span>;</span><br><span class="line">  <span class="attr">src</span> = ./../../$&#123;dpiLibName&#125;; <span class="comment"># 指向 Rust 源码目录</span></span><br><span class="line">  <span class="attr">cargoLock</span> = &#123;</span><br><span class="line">    <span class="attr">lockFile</span> = <span class="string">&quot;<span class="subst">$&#123;src&#125;</span>/Cargo.lock&quot;</span>; <span class="comment"># 锁定依赖版本，保证构建可重现</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>这是标准的 Nix 构建 Rust 项目的方式，会自动下载 Cargo 依赖并编译</li>
</ul>
<h5 id="条件编译特性"><a href="#条件编译特性" class="headerlink" title="条件编译特性"></a>条件编译特性</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">buildFeatures</span> =</span><br><span class="line">    lib.optionals sv2023 [ <span class="string">&quot;sv2023&quot;</span> ]</span><br><span class="line">    ++ lib.optionals vpi [ <span class="string">&quot;vpi&quot;</span> ]</span><br><span class="line">    ++ lib.optionals enable-trace [ <span class="string">&quot;trace&quot;</span> ];</span><br></pre></td></tr></table></figure>
<ul>
<li>这对应了 cargo build –features “…” 命令。Rust 代码中会使用 #[cfg(feature &#x3D; “sv2023”)] 这样的宏来控制代码生成。<ul>
<li><strong>sv2023</strong>: 可能涉及新版 DPI 接口定义的差异。</li>
<li><strong>vpi</strong>: 如果目标仿真器（如 VCS）需要通过 VPI 接口而不是纯 DPI 交互，开启此特性。</li>
<li><strong>trace</strong>: 如果开启，Rust 代码会编译进记录波形的逻辑（通过 fst 或 vcd 库），或者向仿真器注册波形回调。</li>
</ul>
</li>
</ul>
<h5 id="参数注入"><a href="#参数注入" class="headerlink" title="参数注入"></a>参数注入</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">env</span> = &#123;</span><br><span class="line">    <span class="attr">DESIGN_DATA_WIDTH</span> = tbConfig.gcdParameter.width;</span><br><span class="line">    <span class="attr">DESIGN_TIMEOUT</span> = tbConfig.timeout;</span><br><span class="line">    <span class="attr">DESIGN_TEST_SIZE</span> = tbConfig.testSize;</span><br><span class="line">    <span class="attr">CLOCK_FLIP_TIME</span> = tbConfig.testVerbatimParameter.clockFlipTick * timescale;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>通常硬件（Verilog）改了位宽（比如从 32 位改成 64 位），软件测试平台（C++&#x2F;Rust）也得手动改代码，否则就会溢出或错位。这里实现了<strong>参数的透传</strong>。<ul>
<li>Nix 读取 <code>configs/*.json</code> 里的配置（<code>tbConfig</code>）。</li>
<li>在编译 Rust 时，将这些数值设置为<strong>环境变量</strong>。</li>
<li>Rust 代码中可以使用<code>env!(&quot;DESIGN_DATA_WIDTH&quot;)</code>宏在**编译时（Compile time）**读取这些值。</li>
</ul>
</li>
<li>只要改了 JSON 配置文件，Nix 会自动重新编译 Rust 库，生成的测试程序就自动适配了新的硬件参数。<strong>完全杜绝了“硬编码”导致的软硬件参数不一致问题。</strong></li>
</ul>
<h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">passthru</span> = &#123;</span><br><span class="line">    <span class="keyword">inherit</span> enable-trace;</span><br><span class="line">    <span class="keyword">inherit</span> env;</span><br><span class="line">    <span class="attr">libOutName</span> = <span class="string">&quot;lib<span class="subst">$&#123;dpiLibName&#125;</span>.a&quot;</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>libOutName</strong>: 告诉下游使用者（比如 verilated.nix），编译出来的静态库文件名叫什么（例如 libgcdemu.a），方便链接器找到它。</li>
</ul>
</div></article></div><aside id="toc" class="post-toc-sidebar"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E7%9B%AE%E5%BD%95-nix"><span class="toc-number">2.</span> <span class="toc-text">主目录 nix</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%86%85%E9%83%A8-nix"><span class="toc-number">3.</span> <span class="toc-text">模板内部 nix</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8-flake-nix"><span class="toc-number">3.1.</span> <span class="toc-text">外部 flake.nix</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%BA%90%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%BE%93%E5%85%A5-inputs"><span class="toc-number">3.1.1.</span> <span class="toc-text">核心源数据与输入 (inputs)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Flake-%E7%BB%93%E6%9E%84-flake-parts"><span class="toc-number">3.1.2.</span> <span class="toc-text">Flake 结构 (flake-parts)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80-Overlay-%E9%85%8D%E7%BD%AE"><span class="toc-number">3.1.3.</span> <span class="toc-text">全局 Overlay 配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%BA%A7%E9%85%8D%E7%BD%AE-perSystem"><span class="toc-number">3.1.4.</span> <span class="toc-text">系统级配置 (perSystem)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pkgs-%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">pkgs 实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">代码格式化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="toc-number">3.1.4.3.</span> <span class="toc-text">开发环境</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90nix-overlay-nix"><span class="toc-number">3.2.</span> <span class="toc-text">解析nix&#x2F;overlay.nix</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E8%AF%BB%E5%8F%96%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">3.2.1.</span> <span class="toc-text">强制读取环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Overlay-%E4%B8%BB%E4%BD%93"><span class="toc-number">3.2.2.</span> <span class="toc-text">Overlay 主体</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%BC%E5%90%88%E5%B7%A5%E5%85%B7%EF%BC%88espresso%EF%BC%89"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">逻辑综合工具（espresso）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7-mill"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">构建工具 (mill)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%95%86%E4%B8%9A-EDA-%E7%8E%AF%E5%A2%83%E5%B0%81%E8%A3%85-vcs-fhs-env%EF%BC%8Ccds-fhs-env"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">商业 EDA 环境封装 (vcs-fhs-env，cds-fhs-env)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE-gcd"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">本地项目 (gcd)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">3.2.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-nix-pkgs-%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">解析 nix&#x2F;pkgs 文件夹下</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E5%AE%9A%E4%BE%9D%E8%B5%96%E6%BA%90-nixpkgsSrcs-lockedPkgs"><span class="toc-number">3.3.1.</span> <span class="toc-text">锁定依赖源 (nixpkgsSrcs &amp; lockedPkgs)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AE%BF%E4%B8%BB%E7%8E%AF%E5%A2%83%E4%BF%A1%E6%81%AF"><span class="toc-number">3.3.2.</span> <span class="toc-text">获取宿主环境信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA-FHS-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83-buildFHSEnv"><span class="toc-number">3.3.3.</span> <span class="toc-text">构建 FHS 虚拟环境 (buildFHSEnv)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC-profile"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">启动脚本 (profile)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%8C%85%E5%88%97%E8%A1%A8-targetPkgs"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">依赖包列表 (targetPkgs)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Espresso"><span class="toc-number">3.3.4.</span> <span class="toc-text">Espresso</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-nix-gcd-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-number">3.4.</span> <span class="toc-text">解析 nix&#x2F;gcd 文件目录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#defalut-nix-%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.1.</span> <span class="toc-text">defalut.nix 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">基础配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RTL-%E7%94%9F%E6%88%90%E6%B5%81%E7%A8%8B"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">RTL 生成流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BF%E7%9C%9F%E6%B5%81%E7%A8%8B-Simulation-Flow"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">仿真流程 (Simulation Flow)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E7%9A%84%E4%BB%BF%E7%9C%9F%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.1.3.1.</span> <span class="toc-text">具体的仿真器实现</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BD%A2%E5%BC%8F%E9%AA%8C%E8%AF%81%E6%B5%81%E7%A8%8B-Formal-Flow"><span class="toc-number">3.4.1.4.</span> <span class="toc-text">形式验证流程 (Formal Flow)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE"><span class="toc-number">3.4.1.5.</span> <span class="toc-text">其他配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">3.4.1.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gcd-nix-%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.2.</span> <span class="toc-text">gcd.nix 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">依赖管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">入口函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%BF%87%E6%BB%A4"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">源码过滤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">3.4.2.4.</span> <span class="toc-text">构建过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E4%B8%8E%E5%B0%81%E8%A3%85"><span class="toc-number">3.4.2.5.</span> <span class="toc-text">安装与封装</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%AD%98%E6%94%BE-JAR-%E5%8C%85%E7%9A%84%E7%9B%AE%E5%BD%95"><span class="toc-number">3.4.2.5.1.</span> <span class="toc-text">准备存放 JAR 包的目录</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E2%80%9C%E7%A1%AE%E5%AE%9A%E6%80%A7%E2%80%9D%E6%9E%84%E5%BB%BA"><span class="toc-number">3.4.2.5.2.</span> <span class="toc-text">处理“确定性”构建</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BD%92%E6%A1%A3-JAR-%E5%8C%85"><span class="toc-number">3.4.2.5.3.</span> <span class="toc-text">归档 JAR 包</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%8F%AF%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84%E7%9B%AE%E5%BD%95"><span class="toc-number">3.4.2.5.4.</span> <span class="toc-text">准备可执行命令的目录</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">3.4.2.5.5.</span> <span class="toc-text">制作包装器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#shellHook"><span class="toc-number">3.4.2.6.</span> <span class="toc-text">shellHook</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">3.4.2.7.</span> <span class="toc-text">环境变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%EF%BC%88passthru%EF%BC%89"><span class="toc-number">3.4.2.8.</span> <span class="toc-text">开发者工具（passthru）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#elaborate-nix"><span class="toc-number">3.4.3.</span> <span class="toc-text">elaborate.nix</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">输入参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Derivation-%E5%AE%9A%E4%B9%89"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">Derivation 定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC"><span class="toc-number">3.4.3.3.</span> <span class="toc-text">构建脚本</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mlirbc-nix"><span class="toc-number">3.4.4.</span> <span class="toc-text">mlirbc.nix</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC-1"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">构建脚本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rtl-nix"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">rtl.nix</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">3.4.4.3.</span> <span class="toc-text">配置参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86-Layer-%E8%B7%AF%E5%BE%84"><span class="toc-number">3.4.4.4.</span> <span class="toc-text">处理 Layer 路径</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC-2"><span class="toc-number">3.4.4.5.</span> <span class="toc-text">构建脚本</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#verilated-nix-%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.5.</span> <span class="toc-text">verilated.nix 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%E4%B8%8E%E4%BE%9D%E8%B5%96"><span class="toc-number">3.4.5.1.</span> <span class="toc-text">输入参数与依赖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B-1"><span class="toc-number">3.4.5.2.</span> <span class="toc-text">构建过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-number">3.4.5.3.</span> <span class="toc-text">性能调优</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vcs-nix-%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.6.</span> <span class="toc-text">vcs.nix 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E9%98%B6%E6%AE%B5"><span class="toc-number">3.4.6.1.</span> <span class="toc-text">构建阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E4%B8%8E%E5%B0%81%E8%A3%85-1"><span class="toc-number">3.4.6.2.</span> <span class="toc-text">安装与封装</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#vcs-wrapper-sh-%E8%84%9A%E6%9C%AC"><span class="toc-number">3.4.6.2.1.</span> <span class="toc-text">vcs-wrapper.sh 脚本</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Passthru"><span class="toc-number">3.4.6.3.</span> <span class="toc-text">Passthru</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jg-fpv-nix-%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.7.</span> <span class="toc-text">jg-fpv.nix 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-number">3.4.7.1.</span> <span class="toc-text">构建流程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#FPV-tcl-%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.7.1.1.</span> <span class="toc-text">FPV.tcl 文件</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A7%E7%89%A9%E4%BF%9D%E5%AD%98"><span class="toc-number">3.4.7.2.</span> <span class="toc-text">产物保存</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dpi-lib-nix-%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.8.</span> <span class="toc-text">dpi-lib.nix 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="toc-number">3.4.8.1.</span> <span class="toc-text">函数参数与配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Rust-%E5%8C%85%E6%9E%84%E5%BB%BA"><span class="toc-number">3.4.8.2.</span> <span class="toc-text">Rust 包构建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E7%89%B9%E6%80%A7"><span class="toc-number">3.4.8.3.</span> <span class="toc-text">条件编译特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5"><span class="toc-number">3.4.8.4.</span> <span class="toc-text">参数注入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-number">3.4.8.5.</span> <span class="toc-text">输出</span></a></li></ol></li></ol></li></ol></li></ol></aside><a href="#" onclick="toggleTOC();return false;" class="toc-toggle"></a></main><footer><div class="paginator"><a href="/2025/12/18/Rust-net-monitor/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'ssfortynine seansun';
var disqus_identifier = '2025/12/18/Nix-chisel-nix/';
var disqus_title = '看懂chisel-nix项目中的nix框架设计';
var disqus_url = 'https://ssfortynine.github.io/blog/2025/12/18/Nix-chisel-nix/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//ssfortynine seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2025 <a href="https://ssfortynine.github.io/blog">ssfortynine</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/ssfortynine/hexo-theme-apollodark" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>