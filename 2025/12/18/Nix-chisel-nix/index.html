<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 解析基于 Nix 的 Chisel 开发基础设施 Chisel-nix · ssfortynine's Blog</title><meta name="description" content="解析基于 Nix 的 Chisel 开发基础设施 Chisel-nix - ssfortynine"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/cat.png"><link rel="stylesheet" href="/css/apollodark.css"><link rel="search" type="application/opensearchdescription+xml" href="https://ssfortynine.xyz/sitemap.xml/atom.xml" title="ssfortynine's Blog"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="ssfortynine's Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/cat.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/tags" target="_self" class="nav-list-link">TAGS</a></li><li class="nav-list-item"><a href="https://github.com/ssfortynine" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">解析基于 Nix 的 Chisel 开发基础设施 Chisel-nix</h1><div class="post-info">Dec 18, 2025</div><div class="post-content"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>传统的电子设计自动化（EDA）环境长期面临“环境熵增”的困境：闭源商业工具对特定 Linux 发行版的依赖、多版本编译器（JDK&#x2F;LLVM）的冲突以及复杂的许可证（License）管理，导致开发环境难以迁移与复现。</p>
<p>最近研究了 <strong>Chisel-nix</strong> 项目，它利用 Nix 这一声明式包管理器，为 Chisel 硬件开发构建了一套极为现代化的基础设施。</p>
<hr>
<h2 id="声明式环境"><a href="#声明式环境" class="headerlink" title="声明式环境"></a>声明式环境</h2><p>Chisel-nix 的核心在于将<strong>硬件设计流程函数式化</strong>。从源码编译到最终的仿真报告，每一个步骤都是 Nix 依赖图中的一个节点。</p>
<p>针对商业 EDA 工具（如 Synopsys VCS, Cadence JasperGold）深度依赖传统 Linux 文件系统标准（FHS）的问题，Chisel-nix 采用了 <code>buildFHSEnv</code> 技术：</p>
<ul>
<li><strong>命名空间隔离</strong>：在 Nix Store 的只读环境中虚拟化出 <code>/bin, /lib, /usr </code>等标准路径。</li>
<li><strong>Impure 状态注入</strong>：利用 <code>getEnv&#39;</code>函数与 <code>--impure</code> 参数，在保证构建逻辑一致的前提下，动态注入宿主机的 License 路径。</li>
<li><strong>兼容性层</strong>：针对旧版商业软件，通过 Nix 强制挂载 <code>libxcrypt-legacy</code> 等过时库，实现了在现代 NixOS 系统上运行陈旧二进制文件的能力。</li>
</ul>
<h2 id="跨域参数同步"><a href="#跨域参数同步" class="headerlink" title="跨域参数同步"></a>跨域参数同步</h2><p>在复杂的 DPI（Direct Programming Interface）仿真中，最常见的 Bug 来源于软硬件参数的不一致——例如硬件位宽改成了 64 位，但 C++&#x2F;Rust 编写的测试平台仍在使用 32 位。</p>
<p>Chisel-nix 引入了一个非常优雅的<strong>参数同步机制</strong>：</p>
<ol>
<li><strong>统一配置</strong>：在 <code>configs/*.json</code> 中定义所有核心参数（位宽、超时、时钟频率）。</li>
<li><strong>编译时注入</strong>：Nix 在构建流水线中，将这些 JSON 参数转化为环境变量。</li>
<li><strong>自动对齐</strong>：Chisel 侧读取参数生成电路；同时，Rust 编写的 DPI 库在编译时通过 <code>env!</code>宏捕获这些变量。</li>
</ol>
<p>这意味着你只需修改一处 JSON，整个软硬件环境就会自动重构并保持对齐。这种设计极大地降低了系统集成时的低级错误率</p>
<h2 id="细粒度的流水线"><a href="#细粒度的流水线" class="headerlink" title="细粒度的流水线"></a>细粒度的流水线</h2><p>Chisel-nix 将原本笨重的硬件构建流程拆解为多个细粒度的节点，这更像是在用软件工程的思维管理硬件：</p>
<ul>
<li><strong>中间表示（IR）的价值</strong>：它不仅仅是从 Chisel 直接跳到 Verilog，而是经过了 FIRRTL 到 MLIR (CIRCT) 的深度变换。项目将 <code>elaborate</code>、<code>mlirbc</code>、<code>rtl</code> 分别定义为独立的 Derivations。</li>
<li><strong>按需开启的验证层</strong>：通过 Chisel 的 Layers 特性，开发者可以在 <code>rtl.nix</code> 中动态决定是否开启 Assert 或 Probe。这允许我们在不改动核心逻辑代码的情况下，通过 Nix 参数轻松切换“生产模式”和“调试模式”。</li>
</ul>
<h2 id="现代化的验证栈：Rust-DPI-商业工具"><a href="#现代化的验证栈：Rust-DPI-商业工具" class="headerlink" title="现代化的验证栈：Rust + DPI + 商业工具"></a>现代化的验证栈：Rust + DPI + 商业工具</h2><p>Chisel-nix 提供了统一的接口来调用开源（Verilator）与商业（VCS）仿真器。</p>
<ul>
<li><strong>高效的 Rust DPI</strong>：利用 Rust 强大的类型系统和内存安全性编写仿真驱动，相比 C++ 更加稳健。    </li>
<li><strong>商业工具的完美集成</strong>：通过封装脚本（Wrapper），它解决了商业工具运行时需要写权限的问题，并集成了 Verdi 调试数据库（KDB）和覆盖率报告生成。</li>
<li><strong>冒烟测试集成</strong>：每一个仿真器的构建都伴随着一个内嵌的测试作业。这种“构建即测试”的理念，保证了产出的二进制文件永远是可用的。</li>
</ul>
<h2 id="拓展：什么是-passthru"><a href="#拓展：什么是-passthru" class="headerlink" title="拓展：什么是 passthru"></a>拓展：什么是 <code>passthru</code></h2><p>在 Nix 中，<code>stdenv.mkDerivation</code> 是构建软件包的核心。大多数人更注意的是它的 <code>buildPhase</code> 或 <code>installPhase</code> 参数，但在处理像 Chisel-nix 这样复杂的硬件项目时，<code>passthru</code> 的属性提高了整个流水线的灵活性。</p>
<p>在 Chisel-nix 中，<code>passthru</code> 属性完成了三个任务：解决硬件开发中的元数据传递、依赖更新和自动化测试。</p>
<div class="tip">

<h4 id="什么是passthru？"><a href="#什么是passthru？" class="headerlink" title="什么是passthru？"></a>什么是<code>passthru</code>？</h4><p>简单来说，<code>passthru</code> 是一个存放“非构建必需数据”的仓库。它里面的内容不会影响软件包的哈希值（即不触发重新编译），但它允许我们将相关的工具、测试脚本或配置参数与主程序打包在一起。</p>
</div>

<h3 id="开发者工具链的生命周期管理"><a href="#开发者工具链的生命周期管理" class="headerlink" title="开发者工具链的生命周期管理"></a>开发者工具链的生命周期管理</h3><p>在 Nix中，涉及外部依赖的滚动更新（如 Scala 的 Ivy 依赖）为了保证 Nix 构建的确定性，我们需要手动维护一个锁文件（lock file）。Chisel-nix 通过 <code>passthru.bump</code> 将特定于包的维护工具直接封装在构件定义。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">passthru</span> = &#123;</span><br><span class="line">  <span class="attr">bump</span> = writeShellApplication &#123;</span><br><span class="line">    <span class="attr">name</span> = <span class="string">&quot;bump-gcd-mill-lock&quot;</span>;</span><br><span class="line">    <span class="attr">text</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">      mif run -p &quot;<span class="subst">$&#123;src&#125;</span>&quot; -o ./nix/dependencies/locks/gcd-lock.nix &quot;$@&quot;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此举将复杂的依赖更新逻辑（如计算 Maven 坐标的 SHA-256）从宿主系统环境抽象至包级别。开发者无需安装特定的更新器，仅通过 <code>nix run .#package.bump</code> 即可触发闭环的依赖自更新。这种“包即工具箱”的设计，极大地提升了开发者的工作效率。</p>
<h3 id="跨阶段元数据交互与参数同步"><a href="#跨阶段元数据交互与参数同步" class="headerlink" title="跨阶段元数据交互与参数同步"></a>跨阶段元数据交互与参数同步</h3><p>在 Chisel-nix 中硬件流水线采用长链条的变换过程（Scala 编译 -&gt; Elaborate -&gt; MLIR 优化 -&gt; RTL 生成 -&gt; 仿真)。为了让后续步骤知道前一步生成了什么，Chisel-nix 利用 <code>passthru</code> 传递元数据。例如，在 <code>elaborate.nix</code> 中：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">passthru</span> = &#123;</span><br><span class="line">  <span class="keyword">inherit</span> elaborator;</span><br><span class="line">  <span class="keyword">inherit</span> (elaborator) target; <span class="comment"># 将 &quot;GCD&quot; 或 &quot;GCDTestBench&quot; 传给下游</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当后续的 <code>rtl.nix</code> 拿到 <code>elaborate</code> 的输出时，它可以直接通过 <code>elaborate.target</code> 知道顶层模块的名字。这种方式避免了在每个脚本里重复定义参数，保证了整个流水线在不同阶段对“设计目标”的认知是高度统一的。</p>
<h3 id="自动化验证与冒烟测试"><a href="#自动化验证与冒烟测试" class="headerlink" title="自动化验证与冒烟测试"></a>自动化验证与冒烟测试</h3><p>在商业 EDA 流程中，我们经常遇到仿真器编译通过但运行崩溃的情况。Chisel-nix 在 <code>vcs.nix</code> 或 <code>verilated.nix</code> 中利用 <code>passthru.tests</code> 嵌入了自动化验证：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">passthru.tests.<span class="attr">simple-sim</span> = runCommand <span class="string">&quot;<span class="subst">$&#123;binName&#125;</span>-test&quot;</span> &#123; ... &#125; <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;finalAttr.finalPackage&#125;</span>/bin/<span class="subst">$&#123;binName&#125;</span> # 直接运行刚编译出的仿真器</span></span><br><span class="line"><span class="string">  # 检查输出结果并保存至 $out</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>每当你构建一个仿真器，Nix 都会通过这个属性构建立即进行冒烟测试。如果由于链接库或 License 问题导致仿真器无法跑通，Nix 会直接报错并拒绝产出这个包。这种做法就是将<strong>持续集成（CI）逻辑下放到包定义层面</strong>。</li>
</ul>
<h3 id="商业-EDA-环境的透明化"><a href="#商业-EDA-环境的透明化" class="headerlink" title="商业 EDA 环境的透明化"></a>商业 EDA 环境的透明化</h3><p>闭源 EDA 工具通常运行在复杂的 FHS（Filesystem Hierarchy Standard）环境中，其内部逻辑对开发者而言往往是“黑盒”。</p>
<p>Chisel-nix 通过 <code>passthru</code> 将 <code>vcs-fhs-env</code> 等环境定义显式暴露。这一设计方便开发者调试，通过访问 <code>passthru</code> 导出的环境定义快速审查虚拟环境中的库文件组成，从而在闭源二进制程序发生段错误（Segmentation Fault）时，能够精确地进行环境回溯与路径修复。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Chisel-nix 为Chisel 定制了一个<strong>高度自动化且具备强约束力</strong>的协作流程。新学习 Chisel 的开发者和团队无需为环境苦恼，在几秒钟内就可以获得与资深工程师完全一致的开发环境。而且 Chisel-nix 作为一个优秀且有创新的 Nix 框架，具有一定的学习价值。</p>
</div></article></div><aside id="toc" class="post-toc-sidebar"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%8E%AF%E5%A2%83"><span class="toc-number">2.</span> <span class="toc-text">声明式环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E5%8F%82%E6%95%B0%E5%90%8C%E6%AD%A5"><span class="toc-number">3.</span> <span class="toc-text">跨域参数同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%86%E7%B2%92%E5%BA%A6%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">4.</span> <span class="toc-text">细粒度的流水线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3%E5%8C%96%E7%9A%84%E9%AA%8C%E8%AF%81%E6%A0%88%EF%BC%9ARust-DPI-%E5%95%86%E4%B8%9A%E5%B7%A5%E5%85%B7"><span class="toc-number">5.</span> <span class="toc-text">现代化的验证栈：Rust + DPI + 商业工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF-passthru"><span class="toc-number">6.</span> <span class="toc-text">拓展：什么是 passthru</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFpassthru%EF%BC%9F"><span class="toc-number">6.0.1.</span> <span class="toc-text">什么是passthru？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E9%93%BE%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text">开发者工具链的生命周期管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E9%98%B6%E6%AE%B5%E5%85%83%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E4%B8%8E%E5%8F%82%E6%95%B0%E5%90%8C%E6%AD%A5"><span class="toc-number">6.2.</span> <span class="toc-text">跨阶段元数据交互与参数同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E9%AA%8C%E8%AF%81%E4%B8%8E%E5%86%92%E7%83%9F%E6%B5%8B%E8%AF%95"><span class="toc-number">6.3.</span> <span class="toc-text">自动化验证与冒烟测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%95%86%E4%B8%9A-EDA-%E7%8E%AF%E5%A2%83%E7%9A%84%E9%80%8F%E6%98%8E%E5%8C%96"><span class="toc-number">6.4.</span> <span class="toc-text">商业 EDA 环境的透明化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li></ol></aside><a href="#" onclick="toggleTOC();return false;" class="toc-toggle"></a></main><footer><div class="paginator"><a href="/2025/12/18/Rust-net-monitor/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'ssfortynine seansun';
var disqus_identifier = '2025/12/18/Nix-chisel-nix/';
var disqus_title = '解析基于 Nix 的 Chisel 开发基础设施 Chisel-nix';
var disqus_url = 'https://ssfortynine.xyz/sitemap.xml/2025/12/18/Nix-chisel-nix/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//ssfortynine seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2025 <a href="https://ssfortynine.xyz/sitemap.xml">ssfortynine</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/ssfortynine/hexo-theme-apollodark" target="_blank">hexo-theme-apollodark</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>