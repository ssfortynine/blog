<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 用 Rust 构建一个实时的终端网络流量监控器 · ssfortynine's Blog</title><meta name="description" content="用 Rust 构建一个实时的终端网络流量监控器 - ssfortynine"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/cat.png"><link rel="stylesheet" href="/css/apollodark.css"><link rel="search" type="application/opensearchdescription+xml" href="https://ssfortynine.github.io/blog/atom.xml" title="ssfortynine's Blog"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="ssfortynine's Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/cat.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/ssfortynine" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">用 Rust 构建一个实时的终端网络流量监控器</h1><div class="post-info">Dec 18, 2025</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当局域网网速突然变慢时，我们不仅想知道“<strong>网速慢了</strong>”，更想知道“<strong>是谁在占用带宽</strong>”。</p>
<p>虽然 Linux 上有经典的 iftop，但它的界面有些古老。而 btop 虽然界面炫酷，但它主要监控系统资源（CPU&#x2F;内存），在网络流量的具体来源分析上功能有限。</p>
<p>目前可以实现的功能如下，未来如果需要什么功能再增加，复习Rust写的</p>
<ul>
<li><strong>实时流量监控</strong>：基于 <code>libpcap</code> 的底层抓包。</li>
<li><strong>绘制图表</strong>：使用 <code>Ratatui</code> 绘制波形图，类似于 Btop++风格</li>
<li><strong>统计网速</strong>：基于滑动窗口算法计算 1 分钟平均网速，过滤瞬时抖动。</li>
<li><strong>自动日志</strong>：支持流量快照记录，并自动轮转日志文件。</li>
<li><strong>识别主机名和厂商</strong>：支持 DNS 反向解析和 MAC 地址厂商识别（一眼看出是 Apple 还是 Xiaomi）。</li>
</ul>
<p>代码仓库：<a target="_blank" rel="noopener" href="https://github.com/ssfortynine/net_monitor">https://github.com/ssfortynine/net_monitor</a></p>
<div class="tip">

<p>目前识别主机名和厂商，通过 <code>mDNS</code> 识别只能识别一些简单设备（本机以及路由器），其他的设备设置了防火墙，根据这个方法无法读取到主机名。</p>
<ul>
<li>尝试使用了一些网络工具<code>nmlookup</code>也只能查找到小部分，大部分 PC 机查找不到</li>
</ul>
<p>识别厂商名比较简单，只需要识别 MAC 地址的前缀即可, 文件夹下保存了 Nmap MAC 的OUI数据集</p>
<p>虽然可以识别 Vendor ，但是我们实验室使用的机子都是一家厂商，所以 MAC 地址也都一样，所以我就把这个功能搁置了，感觉没有什么用</p>
</div>

<h2 id="Rust-库选择"><a href="#Rust-库选择" class="headerlink" title="Rust 库选择"></a>Rust 库选择</h2><ul>
<li><strong>核心库</strong>：<ul>
<li><code>pcap / pnet</code>: 处理底层网络包捕获。</li>
<li><code>ratatui</code>: 目前 Rust 生态最强大的 TUI 库，用于绘制界面。</li>
<li><code>crossterm</code>: 处理终端输入和原始模式。</li>
</ul>
</li>
<li><strong>辅助库</strong>：<ul>
<li><code>log4rs</code>: 处理日志轮转（限制文件大小、自动删除旧日志）。</li>
<li><code>dns-lookup</code>: 解析 IP 对应的域名。</li>
<li><code>chrono</code>: 时间处理</li>
</ul>
</li>
</ul>
<h2 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h2><p>为了保证界面渲染力流畅不阻塞数据包的捕获，采用经典的多线线程模型：</p>
<ul>
<li><strong>Capture Thread (后台线程)</strong>：负责监听网络接口，解析数据包，统计字节数</li>
<li><strong>UI Thread (主线程)</strong>：负责定时读取数据，更新 UI</li>
<li><strong>Shared State (共享状态)</strong>: 创建了一个 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 结构体，用来共享线程参数</li>
</ul>
<h3 id="全局配置——-constants-rs"><a href="#全局配置——-constants-rs" class="headerlink" title="全局配置—— constants.rs"></a>全局配置—— <code>constants.rs</code></h3><p>定义一些常量配置</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TICK_RATE_MS <span class="comment">// 界面刷新的频率(500ms)</span></span><br><span class="line">HISTORY_WINDOW_SECS <span class="comment">//历史数据保存时间窗口(60s)</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> MAX_SAMPLES: <span class="type">usize</span> = (HISTORY_WINDOW_SECS * <span class="number">1000</span> / TICK_RATE_MS) <span class="keyword">as</span> <span class="type">usize</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>MAX_SAMPLES</code> 决定了在内存中为一个图表保存多少个数据点，比如 <code>60s/0.5s=120</code> 个点。</li>
</ul>
<h3 id="状态更新——-app-rs"><a href="#状态更新——-app-rs" class="headerlink" title="状态更新—— app.rs"></a>状态更新—— <code>app.rs</code></h3><p><code>SharedStats</code> 结构体，用来共享抓包线程和 UI 线程的数据。</p>
<ul>
<li>只保存增量 <code>Delta</code>，即“上一次刷新到现在，又产生了多少流量”。</li>
<li><code>traffic_delta</code>：是一个 <code>HashMap</code> 类型，记录每个 IP 在这 500 ms 内产生的流量</li>
<li>每次 UI 更新之后，这个结构体会被清零，等待下一波数据</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SharedStats</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> traffic_delta: HashMap&lt;Ipv4Addr, <span class="type">u64</span>&gt;,</span><br><span class="line">    <span class="keyword">pub</span> rx_delta: <span class="type">u64</span>,</span><br><span class="line">    <span class="keyword">pub</span> tx_delta: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>IpHistory</code> 结构体，用来记录单个 IP 的历史记录</p>
<ul>
<li><code>samples</code>：使用 <code>VecDeque</code>（双端队列）。实现滑动窗口算法的结构，可以从头部移除旧数据 (<code>pop_front</code>)，从队尾添加新数据 (<code>push_back</code>)</li>
<li><code>update()</code> 方法：接收最新的字节数，计算瞬时速率，更新峰值，并维护队列长度不超过 <code>MAX_SAMPLES</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Single IP history record</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">IpHistory</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> samples: VecDeque&lt;<span class="type">u64</span>&gt;,</span><br><span class="line">    <span class="keyword">pub</span> total_sum: <span class="type">u64</span>,</span><br><span class="line">    <span class="keyword">pub</span> peak_rate: <span class="type">f64</span>,</span><br><span class="line">    <span class="keyword">pub</span> peak_time: DateTime&lt;Local&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">IpHistory</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            samples: VecDeque::<span class="title function_ invoke__">with_capacity</span>(MAX_SAMPLES),</span><br><span class="line">            total_sum: <span class="number">0</span>,</span><br><span class="line">            peak_rate: <span class="number">0.0</span>,</span><br><span class="line">            peak_time: Local::<span class="title function_ invoke__">now</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">update</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, bytes: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">instant_rate</span> = (bytes <span class="keyword">as</span> <span class="type">f64</span>) * (<span class="number">1000.0</span> / TICK_RATE_MS <span class="keyword">as</span> <span class="type">f64</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果本次更新的速率大于峰值速率，刷新峰值速率与时间</span></span><br><span class="line">        <span class="keyword">if</span> instant_rate &gt; <span class="keyword">self</span>.peak_rate &#123;</span><br><span class="line">            <span class="keyword">self</span>.peak_rate = instant_rate;</span><br><span class="line">            <span class="keyword">self</span>.peak_time = Local::<span class="title function_ invoke__">now</span>();</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 采用滑动窗口算法，当样本队列的长度大于最大采样点，就会移出最旧的样本</span></span><br><span class="line">	<span class="comment">// 使用let Some(removed)得到最旧的样本的字节数在total_sum减去这个值</span></span><br><span class="line">        <span class="keyword">self</span>.samples.<span class="title function_ invoke__">push_back</span>(bytes);</span><br><span class="line">        <span class="keyword">self</span>.total_sum += bytes;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.samples.<span class="title function_ invoke__">len</span>() &gt; MAX_SAMPLES &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(removed) = <span class="keyword">self</span>.samples.<span class="title function_ invoke__">pop_front</span>() &#123;</span><br><span class="line">                <span class="keyword">self</span>.total_sum -= removed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">// 计算带宽的速率</span></span><br><span class="line">	<span class="comment">// 总持续时间=样本数量x单个样本时间间隔</span></span><br><span class="line">	<span class="comment">// 速率=总累计值/总持续时间</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">duration_secs</span> = <span class="keyword">self</span>.samples.<span class="title function_ invoke__">len</span>() <span class="keyword">as</span> <span class="type">f64</span> * (TICK_RATE_MS <span class="keyword">as</span> <span class="type">f64</span> / <span class="number">1000.0</span>);</span><br><span class="line">        <span class="keyword">if</span> duration_secs == <span class="number">0.0</span> &#123;</span><br><span class="line">            <span class="number">0.0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.total_sum <span class="keyword">as</span> <span class="type">f64</span> / duration_secs</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>App</code> 结构体，用来定义全局的应用状态</p>
<ul>
<li><code>rx_history</code> &#x2F; <code>tx_history</code>：保存用于在 UI 顶部画波形图的全局历史数据</li>
<li><code>ip_histories</code>：是一个持久化的 Map，即使 <code>SharedStats</code> 被清空了，这里的历史数据依然存在，用于计算长期的平均网速</li>
<li><code>on_tick</code> 方法：是主循环调用的函数，锁定 <code>SharedStats</code>，将后台统计的 <code>rx_delta</code> 和 <code>tx_delta</code>，存入 UI 的历史队列。更新所有的活跃 IP ，使用 <code>update()</code> 方法计算速率。根据带宽使用量对 IP 进行排序，生成 <code>top_talker</code> 列表供 UI 渲染，最后将 <code>SharedStats</code> 重置，计算下一次。</li>
</ul>
<p>这里的 UI 更新线程是消费者，在主线程中捕获数据包线程是生产者，这里使用了多个线程的生产者-消费者模型。<strong>而这两个线程都需要访问一个结构体 <code>SharedStats</code>，所以需要使用 <code>Arc</code> 共享所有权，让多个线程可以安全地持有对同一数据的引用，当所有引用消失时，自动释放内存，并且这里的引用计数是算在原子上，不会引发数据竞争</strong>。</p>
<p>使用 <code>Mutex</code> 互斥锁确保同一时间只有一个线程可以修改数据，防止在读取时数据被其他线程修改。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> App &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">now</span> = Local::<span class="title function_ invoke__">now</span>();</span><br><span class="line">        App &#123;</span><br><span class="line">            rx_history: <span class="built_in">vec!</span>[<span class="number">0.0</span>; MAX_SAMPLES],</span><br><span class="line">            tx_history: <span class="built_in">vec!</span>[<span class="number">0.0</span>; MAX_SAMPLES],</span><br><span class="line">            total_rx_bytes: <span class="number">0</span>,</span><br><span class="line">            total_tx_bytes: <span class="number">0</span>,</span><br><span class="line">            peak_rx_record: (<span class="number">0.0</span>, now),</span><br><span class="line">            peak_tx_record: (<span class="number">0.0</span>, now),</span><br><span class="line">            ip_histories: HashMap::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            top_talkers: <span class="built_in">vec!</span>[],</span><br><span class="line">            last_tick: Instant::<span class="title function_ invoke__">now</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">on_tick</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, shared_stats: &amp;Arc&lt;Mutex&lt;SharedStats&gt;&gt;) &#123;</span><br><span class="line">	<span class="comment">// 获取shared_stats的锁</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stats</span> = shared_stats.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update overall RX/TX history</span></span><br><span class="line">        <span class="keyword">self</span>.rx_history.<span class="title function_ invoke__">remove</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">self</span>.rx_history.<span class="title function_ invoke__">push</span>(stats.rx_delta <span class="keyword">as</span> <span class="type">f64</span>);</span><br><span class="line">        <span class="keyword">self</span>.tx_history.<span class="title function_ invoke__">remove</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">self</span>.tx_history.<span class="title function_ invoke__">push</span>(stats.tx_delta <span class="keyword">as</span> <span class="type">f64</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.total_rx_bytes += stats.rx_delta;</span><br><span class="line">        <span class="keyword">self</span>.total_tx_bytes += stats.tx_delta;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 计算当前的 rx/tx 的速率</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">current_rx_rate</span> = (stats.rx_delta <span class="keyword">as</span> <span class="type">f64</span>) * (<span class="number">1000.0</span> / TICK_RATE_MS <span class="keyword">as</span> <span class="type">f64</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">current_tx_rate</span> = (stats.tx_delta <span class="keyword">as</span> <span class="type">f64</span>) * (<span class="number">1000.0</span> / TICK_RATE_MS <span class="keyword">as</span> <span class="type">f64</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 更新峰值的 rx/tx 的记录</span></span><br><span class="line">        <span class="keyword">if</span> current_rx_rate &gt; <span class="keyword">self</span>.peak_rx_record.<span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.peak_rx_record = (current_rx_rate, Local::<span class="title function_ invoke__">now</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> current_tx_rate &gt; <span class="keyword">self</span>.peak_tx_record.<span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.peak_tx_record = (current_tx_rate, Local::<span class="title function_ invoke__">now</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里创建了一个需要处理的 IP 地址列表，用来合并历史记录中的 IP 和本次新出现的 IP</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">all_ips</span>: <span class="type">Vec</span>&lt;Ipv4Addr&gt; = <span class="keyword">self</span>.ip_histories.<span class="title function_ invoke__">keys</span>().<span class="title function_ invoke__">cloned</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">        <span class="comment">// 遍历本次tick新增的流量数据，寻找他的keys，也就是IP地址</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">k</span> <span class="keyword">in</span> stats.traffic_delta.<span class="title function_ invoke__">keys</span>() &#123;</span><br><span class="line">        <span class="comment">// 只增加哎历史记录中未出现的IP</span></span><br><span class="line">            <span class="keyword">if</span> !<span class="keyword">self</span>.ip_histories.<span class="title function_ invoke__">contains_key</span>(k) &#123;</span><br><span class="line">                all_ips.<span class="title function_ invoke__">push</span>(*k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 创建临时快照</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">current_snapshot</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">ip</span> <span class="keyword">in</span> all_ips &#123;</span><br><span class="line">        <span class="comment">// 获取本次该 IP 的流量增量，如果不存在则为0</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">bytes_in</span> = *stats.traffic_delta.<span class="title function_ invoke__">get</span>(&amp;ip).<span class="title function_ invoke__">unwrap_or</span>(&amp;<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 使用 entry 查找或插入 IP，如果 IP 已存在返回对应的 IpHistory 可变引用</span></span><br><span class="line">            <span class="comment">// 如果 IP 不存在，则创建一个新的 IpHistory 并插入</span></span><br><span class="line">            <span class="comment">// 这里的history类型为 IpHistory，方便后面使用update方法</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">history</span> = <span class="keyword">self</span>.ip_histories.<span class="title function_ invoke__">entry</span>(ip).<span class="title function_ invoke__">or_insert_with</span>(IpHistory::new);</span><br><span class="line">			</span><br><span class="line">	    <span class="comment">// 使用IpHistory的update方法获取平均速率</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">avg_bps</span> = history.<span class="title function_ invoke__">update</span>(bytes_in);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> history.total_sum &gt; <span class="number">0</span> || history.peak_rate &gt; <span class="number">0.0</span> &#123;</span><br><span class="line">                current_snapshot.<span class="title function_ invoke__">push</span>((ip, avg_bps, history.peak_rate, history.peak_time));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.ip_histories.<span class="title function_ invoke__">remove</span>(&amp;ip);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">// 闭包参数 |a,b|, 按照每个元素的第二个字段（平均速率）进行排序</span></span><br><span class="line">	<span class="comment">// 将 b.1 与 a.1 进行比较，为降序排序。b.1 &lt; a.1 返回 Some(Less)</span></span><br><span class="line">        current_snapshot.<span class="title function_ invoke__">sort_by</span>(|a, b| b.<span class="number">1</span>.<span class="title function_ invoke__">partial_cmp</span>(&amp;a.<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        <span class="keyword">self</span>.top_talkers = current_snapshot;</span><br><span class="line"></span><br><span class="line">        stats.traffic_delta.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">        stats.rx_delta = <span class="number">0</span>;</span><br><span class="line">        stats.tx_delta = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里使用的两个函数 API, <code>entry</code>和<code>or_insert_with</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pub <span class="keyword">fn</span> <span class="title function_">entry</span> (&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, key: K) <span class="punctuation">-&gt;</span> Entry&lt;<span class="symbol">&#x27;_</span>, K, V&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回一个<code>Entry</code>枚举，表示键在 HashMap 中的状态</li>
<li><code>Entry</code> 有两种变体：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Entry</span>&lt;<span class="symbol">&#x27;a</span>, K, V&gt; &#123;</span><br><span class="line">	<span class="title function_ invoke__">Occupied</span> (OccupiedEntry&lt;<span class="symbol">&#x27;a</span>, K, V&gt;)， <span class="comment">// 键已存在</span></span><br><span class="line">	<span class="title function_ invoke__">Vacant</span> (VacantEntry&lt;<span class="symbol">&#x27;a</span>, K, V&gt;),   <span class="comment">// 键不存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">or_insert_with</span>&lt;F: <span class="title function_ invoke__">FnOnce</span>() <span class="punctuation">-&gt;</span> V&gt;(<span class="keyword">self</span>, default: F) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> V</span><br></pre></td></tr></table></figure>
<ul>
<li>如果键已存在，返回已有值的可变引用</li>
<li>如果键不存在，执行闭包创建新值，插入 HashMap, 返回新值的可变引用</li>
</ul>
<p><code>entry</code> API 的其他用法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. or_insert - 直接插入值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">history</span> = <span class="keyword">self</span>.ip_histories.<span class="title function_ invoke__">entry</span>(ip).<span class="title function_ invoke__">or_insert</span>(IpHistory::<span class="title function_ invoke__">new</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. and_modify - 对已存在的值进行修改</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">history</span> = <span class="keyword">self</span>.ip_histories</span><br><span class="line">    .<span class="title function_ invoke__">entry</span>(ip)</span><br><span class="line">    .<span class="title function_ invoke__">and_modify</span>(|h| h.<span class="title function_ invoke__">reset</span>())</span><br><span class="line">    .<span class="title function_ invoke__">or_insert_with</span>(IpHistory::new);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. key - 获取键的引用</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">entry</span> = <span class="keyword">self</span>.ip_histories.<span class="title function_ invoke__">entry</span>(ip);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Processing IP: &#123;&#125;&quot;</span>, entry.<span class="title function_ invoke__">key</span>());</span><br></pre></td></tr></table></figure>

<h3 id="数据采集——-network-rs"><a href="#数据采集——-network-rs" class="headerlink" title="数据采集—— network.rs"></a>数据采集—— <code>network.rs</code></h3><p>主要用来与网卡交互、实时捕获流经的数据包，解析协议，并将统计数据传输到共享内存中。这段代码主要依靠两个网络库</p>
<ul>
<li><code>pcap</code>: 它是 C 语言 libpcap (Linux&#x2F;Mac) 或 WinPcap&#x2F;Npcap (Windows) 的 Rust 封装。<ul>
<li><strong>作用</strong>：负责把网卡收到的二进制数据流提取出来。</li>
</ul>
</li>
<li><code>pnet</code>: 一个纯 Rust 的网络库。<ul>
<li><strong>作用</strong>：提供了 EthernetPacket 和 Ipv4Packet 等结构体，能把 pcap 抓到的一堆毫无意义的字节（&amp;[u8]），零拷贝地解析成我们能读懂的 IP 地址、端口和协议类型。</li>
</ul>
</li>
</ul>
<p><code>get_local_ip</code> 函数和 <code>get_defalut_device</code> 函数，自动寻找 ip 和网卡</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_local_ip</span>(device_name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Ipv4Addr&gt; &#123;</span><br><span class="line">	<span class="comment">// 获取系统所有网卡列表</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">interfaces</span> = datalink::<span class="title function_ invoke__">interfaces</span>();</span><br><span class="line">    <span class="comment">// 找到名字匹配的网卡</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">iface</span> = interfaces.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">find</span>(|i| i.name == device_name)?;</span><br><span class="line">    <span class="comment">// 遍历该网卡的所有 IP， 找到第一个 IPv4 地址</span></span><br><span class="line">    iface.ips.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">find_map</span>(|ip| &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">pnet</span>::ipnetwork::IpNetwork::<span class="title function_ invoke__">V4</span>(net) = ip &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(net.<span class="title function_ invoke__">ip</span>())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_default_device</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(Device, Ipv4Addr), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">device</span> = Device::<span class="title function_ invoke__">lookup</span>()?.<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;No default device found&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">device_name</span> = device.name.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">local_ip</span> = <span class="title function_ invoke__">get_local_ip</span>(&amp;device_name).<span class="title function_ invoke__">unwrap_or</span>(Ipv4Addr::<span class="title function_ invoke__">new</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>((device, local_ip))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>该函数返回一个 <code>Result</code>，如果成功则返回一个元组 <code>(Device, Ipv4Addr)</code>。前者是 <code>pcap</code> 库的网卡句柄，后者是标准的 IPv 4 地址。如果失败则返回 <code>Box&lt;dyn Error&gt;&gt;</code>，它可以跑出任意类型的错误（字符串错误、IO 错误等）</li>
<li><code>Device::lookup()</code>：这是 <code>pcap</code> 库提供的功能。它会询问操作系统哪个网卡是默认网关走的网卡（通常是连接互联网的那个，比如 Wi-Fi 或 Ethernet）<ul>
<li><code>?</code> (第一个问号)：处理 <code>lookup</code> 本身可能的系统级错误（比如驱动故障），如果出错，直接抛出</li>
<li><code>ok_or...</code>：<code>lookup</code> 成功时返回的是 <code>Option&lt;Device&gt;</code>，如果是 <code>None</code>，这行代码将其转换为一个包含错误信息的 <code>Err</code></li>
<li><code>?</code>（第二个问号）：如果是 <code>Err</code>，即没有找到设备，直接抛出错误；如果是 <code>Ok</code>，则解包出 <code>device</code> 变量</li>
</ul>
</li>
</ul>
<p><code>is_rfc1918_private</code> 函数用来区分局域网流量和公网流量。基于 RFC 1918 标准的硬编码检查。只有属于这些范围的 IP 才是我们通常意义上的“内网设备”。</p>
<p><code>should_track_ip</code> 函数用来决定是否记录某个 IP 的流量</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">should_track_ip</span>(ip: &amp;Ipv4Addr, filter_cidr: <span class="type">Option</span>&lt;Ipv4Network&gt;) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> filter_cidr &#123;</span><br><span class="line">        <span class="comment">// 模式 1：用户指定了 CIDR（如 10.0.0.0/24），只记录这个子网</span></span><br><span class="line">        <span class="title function_ invoke__">Some</span>(network) =&gt; network.<span class="title function_ invoke__">contains</span>(*ip),</span><br><span class="line">        <span class="comment">// 模式 2：默认模式，记录所有私有 IP</span></span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="title function_ invoke__">is_rfc1918_private</span>(ip),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>利用 match 匹配 Option，既可以监控全内网，也可以监控某个子网。</li>
</ul>
<p><code>start_capture_thread</code> 是核心的抓包函数，启动了一个抓包线程。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cap</span> = Capture::<span class="title function_ invoke__">from_device</span>(device)?</span><br><span class="line">    .<span class="title function_ invoke__">promisc</span>(<span class="literal">true</span>)      <span class="comment">// 混杂模式</span></span><br><span class="line">    .<span class="title function_ invoke__">snaplen</span>(<span class="number">65535</span>)     <span class="comment">// 快照长度</span></span><br><span class="line">    .<span class="title function_ invoke__">timeout</span>(<span class="number">10</span>)        <span class="comment">// 读取超时</span></span><br><span class="line">    .<span class="title function_ invoke__">open</span>()?;</span><br></pre></td></tr></table></figure>
<ul>
<li>在默认情况下，网卡值接收发给自己的包和广播包。开启混杂模式后，网卡会监控所有流经它的数据包。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取原始数据包 (Raw Packet)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(packet) = cap.<span class="title function_ invoke__">next_packet</span>() &#123;</span><br><span class="line">        <span class="comment">// 2. 解析以太网帧 (Ethernet Frame)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(ethernet) = EthernetPacket::<span class="title function_ invoke__">new</span>(packet.data) &#123;</span><br><span class="line">            <span class="comment">// 3. 过滤：只看 IPv4 协议</span></span><br><span class="line">            <span class="keyword">if</span> ethernet.<span class="title function_ invoke__">get_ethertype</span>() == EtherTypes::Ipv4 &#123;</span><br><span class="line">                <span class="comment">// 4. 解析 IPv4 数据包</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(ipv4) = Ipv4Packet::<span class="title function_ invoke__">new</span>(ethernet.<span class="title function_ invoke__">payload</span>()) &#123;</span><br><span class="line">                    <span class="comment">// ... 到了这里，我们终于拿到了 IP 头信息 ...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>if</code> 大法进行解包。网络协议是分层的，最外层是以太网帧，然后确认包里的是 IPv 4, 然后再看 IPv 4 头。如果任意一步解析失败（比如包残缺，或者不是 IPv 4）, 直接跳过，保证程序不崩溃。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = packet.header.len <span class="keyword">as</span> <span class="type">u64</span>; <span class="comment">// 数据包总长度</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">src</span> = ipv4.<span class="title function_ invoke__">get_source</span>();        <span class="comment">// 发送者 IP</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">dst</span> = ipv4.<span class="title function_ invoke__">get_destination</span>();   <span class="comment">// 接收者 IP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取互斥锁</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = stats.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计全局上传/下载</span></span><br><span class="line"><span class="keyword">if</span> src == local_ip &#123;</span><br><span class="line">    s.tx_delta += len; <span class="comment">// 我发的 -&gt; 上传</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    s.rx_delta += len; <span class="comment">// 别人发的（或者发给我的） -&gt; 下载</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计局域网内各 IP 的流量</span></span><br><span class="line"><span class="keyword">if</span> <span class="title function_ invoke__">should_track_ip</span>(&amp;src, filter_cidr) &#123;</span><br><span class="line">    *s.traffic_delta.<span class="title function_ invoke__">entry</span>(src).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>) += len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="title function_ invoke__">should_track_ip</span>(&amp;dst, filter_cidr) &#123;</span><br><span class="line">    *s.traffic_delta.<span class="title function_ invoke__">entry</span>(dst).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>) += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里面也获取了 <code>stats</code> 的锁，用来保存上传&#x2F;下载和流量的记录。代码逻辑比较简单，只要源 IP 不是本机，就算做 RX （接收&#x2F;下载）</li>
</ul>
<h3 id="视图层-TUI-实现-——-ui-rs"><a href="#视图层-TUI-实现-——-ui-rs" class="headerlink" title="视图层 (TUI 实现) —— ui.rs"></a>视图层 (TUI 实现) —— <code>ui.rs</code></h3><p><strong>作用</strong>：使用 Ratatui 库将 App 中的数据渲染到终端屏幕上。<br><strong>详细布局与组件</strong>：</p>
<ol>
<li><code>run</code> 函数<ul>
<li>初始化终端：进入 <code>Raw Mode</code>（禁用行缓冲，按键立即响应），进入 <code>Alternate Screen</code>（类似 Vim 的独立屏幕，退出后恢复原样）。</li>
</ul>
</li>
<li><code>run_app_loop (UI 循环)</code><ul>
<li>这是一个典型的UI 循环：<strong>Draw（绘制） -&gt; Input（处理输入） -&gt; Update（逻辑更新）</strong>。</li>
</ul>
</li>
<li><strong>布局 (Layout)</strong><ul>
<li>使用了 <code>Layout::split</code> 将屏幕切开：<ul>
<li>垂直切分：上（图表）、中（表格）、下（状态栏）。</li>
<li>水平切分（上部）：左（下载图）、右（上传图）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>组件详解</strong><ul>
<li><strong>Canvas (波形图)</strong>:<br>  这是最复杂的部分。<ul>
<li><code>marker(Marker::Braille)</code>: 使用盲文点阵字符（如 ⡀, ⣾）来绘图。相比普通的 ASCII 块，盲文提供了 2x4 的像素分辨率，让曲线看起来非常平滑。</li>
<li>坐标系：X轴是时间（0 到 <code>MAX_SAMPLES</code>），Y轴是速率。</li>
</ul>
</li>
<li><strong>Table (Top Talkers)</strong>:<ul>
<li>根据带宽大小动态改变颜色：超过 1Mb&#x2F;s 显示红色，普通显示绿色。这利用了 Style 结构体。</li>
</ul>
</li>
<li><strong>Paragraph (文本)</strong>:<ul>
<li>显示当前的实时速率和峰值。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="格式化函数——-util-rs"><a href="#格式化函数——-util-rs" class="headerlink" title="格式化函数—— util.rs"></a>格式化函数—— <code>util.rs</code></h3><p>主要是将 bps 以及 bytes_total 设置为 KB，MB，GB 格式</p>
<h3 id="主函数——main-rs"><a href="#主函数——main-rs" class="headerlink" title="主函数——main.rs"></a>主函数——<code>main.rs</code></h3><p>检查是否有输入参数 <code>std::env::args()</code> ，看用户是否想监控特定的子网。调用 <code>network::get_defalut_device()</code> 获取本机 IP，设置共享内存初始化 <code>stats</code> 并启动捕获包线程，启动 UI 线程以及退出处理。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cidr_arg</span> = args.<span class="title function_ invoke__">get</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filter_cidr</span>: <span class="type">Option</span>&lt;Ipv4Network&gt; = <span class="keyword">match</span> cidr_arg &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(s) =&gt; &#123;</span><br><span class="line">            <span class="keyword">match</span> s.<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(net) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;Filter mode: Targeting subnet &#123;&#125;&quot;</span>, net);</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(net)</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(_) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">eprintln!</span>(<span class="string">&quot;Invalid CIDR provided &#x27;&#123;&#125;&#x27;, falling back to default private ranges.&quot;</span>, s);</span><br><span class="line">                    <span class="literal">None</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;No subnet provided. Targeting all standard private networks (RFC1918).&quot;</span>);</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// network module to get default device and local IP</span></span><br><span class="line">    <span class="keyword">let</span> (device, local_ip) = network::<span class="title function_ invoke__">get_default_device</span>()?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">device_name</span> = device.name.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shared stats between capture thread and UI thread</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stats</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(SharedStats &#123;</span><br><span class="line">        traffic_delta: HashMap::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        rx_delta: <span class="number">0</span>,</span><br><span class="line">        tx_delta: <span class="number">0</span>,</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    network::<span class="title function_ invoke__">start_capture_thread</span>(device, local_ip, Arc::<span class="title function_ invoke__">clone</span>(&amp;stats), filter_cidr)?;</span><br><span class="line">    ui::<span class="title function_ invoke__">run</span>(stats, &amp;device_name)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>OUI 数据库的来源：github.com&#x2F;Ringmast4r&#x2F;OUI-Master-Database?tab&#x3D;readme-ov-file</p>
</div></article></div><aside id="toc" class="post-toc-sidebar"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rust-%E5%BA%93%E9%80%89%E6%8B%A9"><span class="toc-number">2.</span> <span class="toc-text">Rust 库选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.</span> <span class="toc-text">整体设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94-constants-rs"><span class="toc-number">3.1.</span> <span class="toc-text">全局配置—— constants.rs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E2%80%94%E2%80%94-app-rs"><span class="toc-number">3.2.</span> <span class="toc-text">状态更新—— app.rs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E2%80%94%E2%80%94-network-rs"><span class="toc-number">3.3.</span> <span class="toc-text">数据采集—— network.rs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E5%B1%82-TUI-%E5%AE%9E%E7%8E%B0-%E2%80%94%E2%80%94-ui-rs"><span class="toc-number">3.4.</span> <span class="toc-text">视图层 (TUI 实现) —— ui.rs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94-util-rs"><span class="toc-number">3.5.</span> <span class="toc-text">格式化函数—— util.rs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94main-rs"><span class="toc-number">3.6.</span> <span class="toc-text">主函数——main.rs</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol></aside><a href="#" onclick="toggleTOC();return false;" class="toc-toggle"></a></main><footer><div class="paginator"><a href="/2025/12/18/Nix-chisel-nix/" class="prev">PREV</a><a href="/2025/12/10/FPT2025-LL-ViT/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'ssfortynine seansun';
var disqus_identifier = '2025/12/18/Rust-net-monitor/';
var disqus_title = '用 Rust 构建一个实时的终端网络流量监控器';
var disqus_url = 'https://ssfortynine.github.io/blog/2025/12/18/Rust-net-monitor/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//ssfortynine seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2025 <a href="https://ssfortynine.github.io/blog">ssfortynine</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/ssfortynine/hexo-theme-apollodark" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>