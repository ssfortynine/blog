<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HardwareDesign1</title>
      <link href="/2024/07/25/HardwareDesign1/"/>
      <url>/2024/07/25/HardwareDesign1/</url>
      
        <content type="html"><![CDATA[<p>硬件加速设计方法：专题一 高质量VerilogHDL描述方法</p><span id="more"></span><h2 id="VerilogHDL-可综合描述"><a href="#VerilogHDL-可综合描述" class="headerlink" title="VerilogHDL 可综合描述"></a>VerilogHDL 可综合描述</h2><p>VerilogHDL 是描述可综合的硬件电路<br>HDL 语言具有以下的硬件设计的基本概念</p><ul><li><mark style="background: #FFB8EBA6;">互联 (connectivity)</mark> - wire 型变量描述各个模块之间的端口和网线连接关系</li><li><mark style="background: #FFB8EBA6;">并发 (concurrency) </mark>- 可以有效地描述并行的硬件系统</li><li><mark style="background: #FFB8EBA6;">时间 (time) </mark>- 定义了绝对和相对的时间度量，可综合操作符都是具有物理延时的</li></ul><h2 id="Verilog-HDL-用于可综合描述的语句"><a href="#Verilog-HDL-用于可综合描述的语句" class="headerlink" title="Verilog HDL 用于可综合描述的语句"></a>Verilog HDL 用于可综合描述的语句</h2><h3 id="可用于综合的语句"><a href="#可用于综合的语句" class="headerlink" title="可用于综合的语句"></a>可用于综合的语句</h3><p><mark style="background: #FFF3A3A6;">always</mark><br><mark style="background: #FFF3A3A6;">if-else</mark>: 映射的硬件结构-多路选择器，输出结果由输入的选择确定</p><ul><li>代码和电路是互相等价的。<mark style="background: #FFB8EBA6;">硬件结构比较复杂，以及控制通道的延迟</mark>等。代码在书写的时候就要注意<mark style="background: #FFB8EBA6;">综合电路的性能最优化</mark>，要综合考虑硬件电路的性能和结构。</li><li>要根据输入约束，小心设计：<mark style="background: #FFF3A3A6;">先”加”后“选”</mark>，还是<mark style="background: #FFF3A3A6;">先”选”后“加”</mark></li><li><mark style="background: #FFB8EBA6;">单 if 语句</mark>：无优先级的判断结构，描述多条件判断结构</li><li><mark style="background: #FFB8EBA6;">多 if 语句</mark>：有优先级的判断结构，<mark style="background: #FFF3A3A6;">最后一级信号具有最高优先级，具有优先级的多选结构会消耗组合逻辑</mark>。若某些设计中，有些信号要求先到达（如<mark style="background: #BBFABBA6;">关键使能信号、选择信号</mark>等），有些信号要求后到达（如<mark style="background: #BBFABBA6;">慢速信号、有效时间较长的信号</mark>等），此时需要使用 if..if 语句。设计方法：最高优先级给最迟到达的关键信号<br><mark style="background: #FFF3A3A6;">case</mark>：无优先级的判断结构，与单 if 语句的区别是条件互斥，通常用于指令编码译码电路<br><mark style="background: #FFF3A3A6;">assign</mark></li></ul><h3 id="不可用于综合的语句"><a href="#不可用于综合的语句" class="headerlink" title="不可用于综合的语句"></a>不可用于综合的语句</h3><p><mark style="background: #FFF3A3A6;">function</mark>、<mark style="background: #FFF3A3A6;">for </mark>、<mark style="background: #FFF3A3A6;">fork-join</mark>、<mark style="background: #FFF3A3A6;">while</mark></p><h3 id="Latch和D触发器"><a href="#Latch和D触发器" class="headerlink" title="Latch和D触发器"></a>Latch和D触发器</h3><p>一般情况下避免使用 latch (锁存器)，一般只有在异步电路和门控时钟时会用到 latch<br><img src="/assets/Pasted_image_20231024202936.png"><br>latch 是电平触发，非同步控制。DFF 由时钟沿触发，同步控制。Latch 容易产生毛刺（glitch），而 DFF 不易产生毛刺。<br>latch 将 STA 变得复杂。因为 Latch 不能过滤毛刺，对下一级电路极其危险，所以避免产生 Latch, 尽可能使用 D 触发器</p><h3 id="避免产生-Latch-的措施"><a href="#避免产生-Latch-的措施" class="headerlink" title="避免产生 Latch 的措施"></a>避免产生 Latch 的措施</h3><p>易引入 latch 的途径：使用不完备的条件判断语句（if-else 语句缺少 else、case 语句缺少 default）</p><blockquote><p>防止产生 latch 的措施</p><ol><li>使用完备的 if… Else 语句</li><li>为每个输入条件设计输出操作，为 case 语句设置 default 操作</li><li>仔细检查综合器生成的报告，latch 会以 warning 的形式报告</li></ol></blockquote><h3 id="full-case-和-parallel-case-综合器指令"><a href="#full-case-和-parallel-case-综合器指令" class="headerlink" title="full-case 和 parallel-case 综合器指令"></a>full-case 和 parallel-case 综合器指令</h3><p>有时会出现设计目标缘故产生 Latch<br>full-case: 告诉综合器，当前 case 结构所列条件已完备(<code>//synopsys full_case</code>)<br>parallel-case: 告诉 DC，所有条件均互斥，且并行，无优先权(<code>//synopsys parallel_case</code>)</p><p><strong>逻辑复制-&gt;均衡负载</strong><br>通过逻辑复制，降低关键信号的扇出，进而降低该信号的传播延迟，提高电路性能</p><p><strong>资源共享-&gt;减小面积</strong><br>一般进行资源共享会减小电路面积，但是性能会下降，要综合考虑性能和面积而进行取舍</p><p><strong>资源顺序重排-&gt;降低传播延时</strong><br>如果一个输入信号来的晚我们可以尽可能的把它放在后面，隐藏其延迟</p><p><strong>assign 仅用来连线，always 用于逻辑运算</strong><br>尽量少用 assign 进行逻辑运算，不仅难以阅读，且多层嵌套之后很难被综合器解释(不过现在好像更多用是<code>assign</code>来描述逻辑电路)</p><h3 id="可综合风格"><a href="#可综合风格" class="headerlink" title="可综合风格"></a>可综合风格</h3><p><strong>完整的 <code>always</code>  敏感信号列表</strong><br>敏感信号列表必须包含输入信号</p><ul><li>原因：综合过程中会产生一个取决于除敏感列表中所有其他值的结构，它将可能在行为仿真和门级仿真间产生潜在的失配</li></ul><p><strong>每个 <code>always</code> 敏感信号列表只能对应一个时钟</strong></p><ul><li>将每个过程限制在单一寄存器中，有利于 STA 和逻辑综合</li></ul><p><strong>不允许 <code>wait</code> 声明和 <code>#delay</code> 声明</strong>  </p><ul><li>综合器不允许，但是可以在测试模块和表示行为的虚拟模块中使用<blockquote><p>语法说明<br>在时序电路中必须使用非阻塞赋值 <code>&lt;=</code><br>在组合逻辑电路中必须使用阻塞赋值 <code>=</code></p></blockquote></li></ul><h3 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h3><p><strong>分开异步逻辑和同步逻辑</strong></p><ul><li>原因：避免综合时的问题，简化约束和编码难度。</li><li>例外：不可应用于非综合模块中（例如：总线模块、总线监视器或是模拟模块）除非他们被设计来综合仿真</li></ul><p><strong>分开控制逻辑和存储器模块</strong></p><ul><li>通常来说，存储器都是用 memory complier 来生成的，其综合方式和 RTL 代码不同，混合在一起不利于综合，不利于很方便地更换工艺库和平台</li></ul><h3 id="在-RTL-书写中如何考虑延迟、面积等"><a href="#在-RTL-书写中如何考虑延迟、面积等" class="headerlink" title="在 RTL 书写中如何考虑延迟、面积等"></a>在 RTL 书写中如何考虑延迟、面积等</h3><p><strong>在 RTL 代码中考虑时</strong></p><ul><li>针对控制信号来到比较晚，尽可能<mark style="background: #FFB86CA6;">将延时较大的分支单独拿出来，放在出口最近的选择器中</mark></li><li>注意<mark style="background: #FFB86CA6;">“先加后选”</mark>和<mark style="background: #FFB86CA6;">“先选后加”</mark></li><li><mark style="background: #FFB86CA6;">加法器、乘法器等复杂的器件少用</mark></li><li>减少设计面积：首先要估计使用设计资源的数量，比如使用了多少触发器、加法器、乘法器。可以借助工具，<mark style="background: #FFB86CA6;">最终应该知道在设计中哪些部分占了较大的面积，进而分析和改进</mark></li><li>一般来说触发器由功能决定，很难减少，只能从组合逻辑出发。对于 RTL 代码，就是各种操作符，应该了解<mark style="background: #FFB86CA6;">各种操作符对应的电路</mark>，如使用<mark style="background: #FFB8EBA6;">“+”、”-“、”x”、”&#x2F;“</mark>以及一些条件语句中的比较运算，对于这些操作，<mark style="background: #FFB86CA6;">首先判断其必要性，是否能用更简单的方法解决</mark></li><li>如果必须使用复杂的运算符，应考虑<mark style="background: #FFB86CA6;">资源共享</mark>，从代码出发，而不是只依靠综合器</li><li>多比特的信号也会占用大量的资源，针对不同的设计有不同的改进方法，对于有可能简化的地方尽可能简化，<u>逻辑简化的同时也对应面积减少和时延减少</u></li></ul><p><strong>对于功耗控制</strong></p><ul><li><mark style="background: #FFB86CA6;">门控时钟</mark>，时钟电路的翻转消耗大量资源，此时可以使用门控时钟，减少时钟电路的翻转</li><li><mark style="background: #FFB86CA6;">增加使能信号</mark>，使得部分电路只有工作的时候才工作，与门控时钟的差别在与，使用使能信号只使得被控制的电路不再工作，但是其时钟仍然在工作，而门控时钟是使时钟停止工作</li><li><mark style="background: #FFB86CA6;">对芯片各个模块进行控制，只有工作的时候才使用</mark></li><li>除了有用信号和时钟的翻转会消耗功耗，组合逻辑的毛刺也会大量消耗功耗，但是在设计过程中毛刺是不可避免的，但是要尽量<mark style="background: #FFB86CA6;">减少毛刺的传播</mark>，才可以减少功耗。</li><li>有限状态机，通过<mark style="background: #FFB86CA6;">低功耗编码</mark>来减少电路的翻转，比如独热码</li><li>在 RTL 编码阶段对布局布线进行考虑，避免无法布通的情况。<u>如果采用大的 mux，可以将其分解为多级较小的 mux。</u></li></ul><h2 id="RTL-设计指导规则"><a href="#RTL-设计指导规则" class="headerlink" title="RTL 设计指导规则"></a>RTL 设计指导规则</h2><ul><li>RTL 级的设计评判标准很多，如<mark style="background: #FFB86CA6;">时序性能、所占面积、可测试性、可重用性、功耗、时钟域的分配、复位信号设计以及与所用 EDA 工具匹配等</mark>。</li><li>一般的指导原则：面积与速度互换、乒乓操作、流水线设计</li></ul><h3 id="面积与速度互换"><a href="#面积与速度互换" class="headerlink" title="面积与速度互换"></a>面积与速度互换</h3><p>面积：一个设计所消耗的目标器件的<mark style="background: #FFB86CA6;">硬件资源数量</mark>或者 <mark style="background: #FFB86CA6;">ASIC 芯片面积</mark></p><ul><li>FPGA 可以用所消耗的<mark style="background: #FF5582A6;">触发器CFF</mark> 和<mark style="background: #FF5582A6;">查找表数量</mark>来衡量<br>速度：设计在芯片上稳定运行时所能达到的最高频率，这个频率一般由设计的时序状况来决定</li><li>时序特征向量：<mark style="background: #FFB86CA6;">时钟周期，PAD to PAD time，Clock setup time, Clock hold time, Clock-to-Output Delay</mark><br>科学的设计目标：</li><li><u>在满足设计时序的要求（包含对设计的最高频率要求）的前提下，占用最小的芯片面积。</u></li><li><u>在所规定的面积下，使设计的时序余量更大，频率更高。</u></li><li>如果设计的时序余量更大，频率更高——设计的健壮性更强, 整个系统的设计质量更有保证</li><li>设计所消耗的面积小——在单位芯片上实现的功能更多，需要的芯片数量更少，成本更低</li><li>满足时序和工作频率的要求更高，即速度优先<img src=/assets/Pasted_image_20231025195027.png width=80% /></li></ul><blockquote><p>速度与面积互换</p><ol><li>如果时序余量大，速度-&gt;面积<ul><li>模块复用</li></ul></li><li>如果一个设计时序要求高，普通方法达不到设计频率<ul><li>数据流串并转换</li><li>并行复制多个操作模块</li><li>“乒乓操作”和“串并转换”</li><li>在芯片模块输出处在对数据进行“并串转换”</li></ul></li></ol></blockquote><h3 id="乒乓操作"><a href="#乒乓操作" class="headerlink" title="乒乓操作"></a>乒乓操作</h3><ul><li>乒乓操作一个常常用于数据流控制的处理方法<img src=/assets/Pasted_image_20231025195210.png width=80% /></li><li><mark style="background: #FFB86CA6;">节约缓冲区</mark></li><li><mark style="background: #FFB86CA6;">巧妙运用乒乓操作可以做到低速模块处理高速数据流的效果</mark></li></ul><h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><ul><li><p>电路的最高频率取决于最长的组合逻辑链路的延迟值</p><img src=/assets/Pasted_image_20231025200113.png width=80% /></li><li><p>流水线当方法可以有效提高系统的工作频率，但是考虑一个电路的性能通常都是<mark style="background: #FF5582A6;">其单位时间的计算量，或者是一定计算总量下的处理时间</mark></p><img src=/assets/Pasted_image_20231025200349.png width=80% /></li></ul><p><strong>特点</strong></p><ul><li>通过<mark style="background: #FFB86CA6;">插入寄存器</mark>，将长的串行逻辑链分成较小的部分</li><li>当系统运算是串行时，利用时钟控制，使运算依照顺序接续执行</li><li>在任何制定时刻，大部分电路都在运行</li></ul><p><strong>好处</strong></p><ul><li><mark style="background: #FFB86CA6;">每一部分延时更小-&gt;可使用更快的时钟</mark></li><li><mark style="background: #FFB86CA6;">大部分电路同时进行计算-&gt;可提高数据通过量（吞吐量）</mark></li></ul><p><strong>流水线参数设计</strong></p><ul><li>系统时钟取决于最慢的流水线级的延时<ul><li>流水线时钟周期：$$T_{pipe} &#x3D; max{T_1,T_2,…,T_m}$$</li><li>第 i 级的时钟周期：$$T_i&gt;t_ff+…+t_{su}+t_{d,i}+t_{s,i}+1$$</li></ul></li><li>流水线分割点及参数确定要考虑的因素<ul><li><mark style="background: #FFB8EBA6;">单位延迟时间及时间频率的大小决定了数据通过速率</mark></li><li><mark style="background: #FFB8EBA6;">过多的级数不一定能产生最快的结果</mark></li><li><mark style="background: #FFB8EBA6;">太多的寄存器的插入会导致芯片面积的增加，布线困难，时钟偏差增加</mark></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Zerotier-Archlinux-Termius互通教程</title>
      <link href="/2024/07/24/Zerotier/"/>
      <url>/2024/07/24/Zerotier/</url>
      
        <content type="html"><![CDATA[<p>使用Zerotier 和Termius 通过SSH创建个人PC服务器,并且用ipad连接Archlinux</p><span id="more"></span><h2 id="Zerotier的配置和使用"><a href="#Zerotier的配置和使用" class="headerlink" title="Zerotier的配置和使用"></a>Zerotier的配置和使用</h2><p>Zerotier 是一款不需要公网 IP 内网穿透软件，<code>ZeroTier</code> 是一个专门用来建立点对点虚拟专用网（<code>P2P VPN</code>）的工具，它提供在线管理界面和全平台的客户端，不需要复杂设置，只要安装客户端并加入到自己创建的网络即可。</p><blockquote><ol><li>官方网站地址：<a href="https://www.zerotier.com/">https://www.zerotier.com</a></li></ol></blockquote><blockquote><ol start="2"><li>项目地址：<a href="https://github.com/zerotier">https://github.com/zerotier</a></li></ol></blockquote><h2 id="注册和客户端安装"><a href="#注册和客户端安装" class="headerlink" title="注册和客户端安装"></a>注册和客户端安装</h2><h3 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h3><p>ZeroTier 可以通过邮箱或者 <code>Google</code> <code>Github</code> <code>Microsoft</code> 账号注册。</p><p><img src="/assets/image5.png"></p><p>进入 Zerotier 之后就可以创建你的 Networks。<code>NETWORK ID</code> 是客户端连接到行星服务器的唯一识别码，需要牢记, 即每个客户端需要 Join 的 ID, <code>NAME</code> 可以随意更改。</p><p><img src="/assets/image2.png"></p><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p><code>SUBNET</code> 是 <code>Zerotier One</code> 使用 <code>STUN</code> 和隧道建立的 <code>NAT</code>，可以更改内网 ip 网段。<code>NODES</code> 是连入 <code>NETWORK</code> 的设备数，以及建立时间 <code>CREATED</code>。</p><p><img src="/assets/image1.png"></p><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p><code>ZeroTier</code> 支持 <code>Windows</code>、<code>macOS</code>、<code>Linux</code> 三大桌面平台，<code>iOS</code>、<code>Android</code> 两大移动平台，<code>QNAP（威连通）</code>、<code>Synology（群晖）</code>、<code>Western Digital MyCloud NAS（西部数据）</code> 三个 <code>NAS</code> 平台，还支持 <code>OpenWrt/LEDE</code> 开源路由器项目。</p><blockquote><p>下载地址：<a href="https://www.zerotier.com/download/">https://www.zerotier.com/download/</a></p></blockquote><p>这里以 <code>Ipad</code> 、<code>Andriod </code>、<code>Archlinux</code> 设备为例介绍一下客户端如何与 <code>planet</code> 相连接挂载到内网地址。</p><p><code>ios</code> 设备通过 <code>Appstore</code> 下载，<code>Andriod</code> 设备通过下载地址下载即可。<code>Network ID</code>，配置好 <code>VPN</code> 后就会启动连接。</p><p><code>SUBNET</code> 是 <code>Zerotier One</code> 使用 <code>STUN</code> 和隧道建立的 <code>NAT</code>，可以更改内网 ip 网段。<code>NODES</code> 是连入 <code>NETWORK</code> 的设备数，以及建立时间 <code>CREATED</code>。</p><p><img src="/assets/image1.jpg"></p><p><img src="/assets/image2.jpg"></p><p><code>Android</code> 使用方法同理。</p><img src=/assets/image3.jpg width=60% /><img src=/assets/image4.jpg width=60% /><p><code>Archlinux</code> 在 <code>Termial</code> 中使用命令行下载和启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装zerotier-one</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> pacman -S zerotier-one</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启和加入开机自启</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl start zerotier-one.service</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl <span class="built_in">enable</span> zerotier-one.service</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加入、离开、列出网络</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> zerotier-cli <span class="built_in">join</span> [此处<span class="built_in">id</span>]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> zerotier-cli leave</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> zerotier-cli listnetworks</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取地址和服务状态</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> zerotier-cli status</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>这时会根据 <code>MAC</code> 地址分配给设备一个唯一认证字符串 <code>Node ID</code>，可用来在 <code>Web</code> 配置界面保留该设备不被删除以及帮助我们区分设备。我们在 <code>Auth?</code> 处勾上就可以让设备连接到 <code>planet</code> 中。</p><p><img src="/assets/image6.png"></p><h2 id="Ipad-SSH"><a href="#Ipad-SSH" class="headerlink" title="Ipad SSH"></a>Ipad SSH</h2><p>理论上来说在同一个局域网下 <code>ssh</code> 可以通过设备的 <code>IP</code> 地址来连接，此时我们通过 <code>Zerotier</code> 使不同局域网下的设备处于统一 <code>Networks</code> 下，只要 <code>ssh Managed IP</code> 即可完成设备间的互访。</p><h3 id="Termius"><a href="#Termius" class="headerlink" title="Termius"></a>Termius</h3><p><code>Termius</code> 是一个非常好用的 <code>SSH</code> 客户端，免费版就已经提供了 <code>SSH</code> 功能，满足我们连接并操作 <code>Archlinux </code> 的需求。<code>IOS</code> 通过 <code>appstore</code> 下载，<code>Andriod</code> 通过 <code>google play</code> 商店下载，这里以 <code>ipad</code> 设备为例对 <code>archlinux</code> 设备进行访问。在 termius 的设置中要输入连接名称 alias (随便取)、IP 地址（这里你要访问设备的 Managed IP 地址，在 Zerotier 配置页面）、SSH 端口号、用户名与密码。</p><p><img src="/assets/image5.jpg"></p><img src=/assets/image6.jpg width=60% /><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>Archlinux 需要设置 SSH 服务，下载配置命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载SSH</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> pacman -S openssh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行Open SSH</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl start sshd</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Open SSH状态</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl status sshd</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">终止SSH服务器</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl stop sshd</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">系统重新启动时自动启动 SSH 服务器</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> sshd</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从系统启动中删除</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> sshd</span></span><br></pre></td></tr></table></figure><p>下载配置启动 SSH 之后我们要对 SSH 配置文件中修改一些选项，以方便 ipad 或者其他设备可以连接到 linux服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> nvim /etc/ssh/sshd_config</span> </span><br></pre></td></tr></table></figure><p>我们可以在这个配置文件中修改我们的 SSH 端口，默认是 22。以及 Authentication 的状态，将 <code>PermitRootLogin</code> 设置为 <code>yes</code> 并且取消注释，就可以让访问设备打开 ROOT 权限。通过 <code>PubkeyAuthentication</code> 设置为 <code>yes</code> 那么只能允许服务器承认的 key 可以连接。修改完配置文件使用 <code>sudo systemctl restart sshd</code> 重新打开 ssh。</p><img src=/assets/image7.png width=40% /><img src=/assets/image8.png width=40% /><img src=/assets/image9.png width=100% /><h3 id="测试设备间互访"><a href="#测试设备间互访" class="headerlink" title="测试设备间互访"></a>测试设备间互访</h3><p>不同网络访问：<code>Archlinux</code> 连接 <code>5g</code> 网络，<code>iPad</code> 连接 <code>wifi</code>。</p><p><img src="/assets/image5.jpg"></p><p>从图中我们可以看到已经成功连接上了 <code>Archlinux</code> 的 <code>SSH</code>。由于免费的根服务器在国外，可能访问速度不太稳定。 </p><h2 id="笔记本不休眠"><a href="#笔记本不休眠" class="headerlink" title="笔记本不休眠"></a>笔记本不休眠</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 编辑文件</span><br><span class="line">$ sudo nvim /etc/systemd/logind.conf</span><br><span class="line"># 将其中</span><br><span class="line">#HandleLidSwitch=suspend</span><br><span class="line"># 去掉前面的#改成</span><br><span class="line">HandleLidSwitch=ignore</span><br><span class="line"># 最后重启服务</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Tool </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
