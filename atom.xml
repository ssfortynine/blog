<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ssfortynine&#39;s Blog</title>
  
  
  <link href="https://ssfortynine.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://ssfortynine.github.io/blog/"/>
  <updated>2025-11-22T08:17:23.242Z</updated>
  <id>https://ssfortynine.github.io/blog/</id>
  
  <author>
    <name>ssfortynine</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Obsidian-NAS极空间-Cpolar同步</title>
    <link href="https://ssfortynine.github.io/blog/2025/11/21/Obsidian-NAS%E6%9E%81%E7%A9%BA%E9%97%B4-Cpolar%E5%90%8C%E6%AD%A5/"/>
    <id>https://ssfortynine.github.io/blog/2025/11/21/Obsidian-NAS%E6%9E%81%E7%A9%BA%E9%97%B4-Cpolar%E5%90%8C%E6%AD%A5/</id>
    <published>2025-11-21T08:52:00.000Z</published>
    <updated>2025-11-22T08:17:23.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="试错-Tailscale-多端同步"><a href="#试错-Tailscale-多端同步" class="headerlink" title="试错 Tailscale 多端同步"></a>试错 Tailscale 多端同步</h2><ul><li><a href="https://post.smzdm.com/p/agqd5k87/p2/?sort_tab=hot/#comments">教程：使用tailscale内网穿透访问你家的极空间</a><br>根据网上的一些教程，通过使用 Tailscale 与 NAS 极空间完成多平台的同步，但是失败了，无法连接到公网。</li></ul><h2 id="使用-Cpolar-同步"><a href="#使用-Cpolar-同步" class="headerlink" title="使用 Cpolar 同步"></a>使用 Cpolar 同步</h2><p><code>Cpolar</code> 比 Tailscale 操作简单很多，只需要下载，以及注册一个账号即可，剩下不需要什么操作。这个教程，省略了使用 <code>Cpolar</code> 的内容</p><ul><li><a href="https://zhuanlan.zhihu.com/p/702018896">教程：极空间+obsidian 同步</a></li></ul><h3 id="在-NAS-极空间中搜索-docker-仓库-Cpolar（踩坑）"><a href="#在-NAS-极空间中搜索-docker-仓库-Cpolar（踩坑）" class="headerlink" title="在 NAS 极空间中搜索 docker 仓库 Cpolar（踩坑）"></a>在 NAS 极空间中搜索 docker 仓库 Cpolar（踩坑）</h3><p>根据教程，在 NAS 极空间 docker 仓库中搜索出来的 Cpolar 部署的容器无法正常运行，一直在重启</p><ul><li><a href="https://www.bilibili.com/opus/978709685396832281">教程：Cpolar 极空间 docker 部署</a></li></ul><h3 id="使用-SSH-安装-Cpolar"><a href="#使用-SSH-安装-Cpolar" class="headerlink" title="使用 SSH 安装 Cpolar"></a>使用 SSH 安装 Cpolar</h3><p>换了一种方式通过 <code>SSH</code> 连接到 NAS 极空间中，下载 Cpolar 运行即可</p><ul><li><a href="https://mp.weixin.qq.com/s/S9vwpHMeXT3sHs8NbJdrzA">教程：极空间 SSH 公网配置</a></li></ul><p>根据上述教程中的配置，将极空间内的 SSH 设置打开，连接到客户端上之后，在本地安装 cpolar<br><img src="/assets/file-20251121155439308.png" alt="alt text"></p><blockquote><p>[!tip] 什么是 cpolar<br>Cpolar 是一款强大的内网穿透工具，无需公网 IP、无需路由器设置，只需要在本地设备上运行一个客户端，就能将内网的 SSH 服务安全地映射到一个公网可访问的地址</p></blockquote><p><strong>以下是安装cpolar 步骤：</strong><br>官网在此：<a href="https://www.cpolar.com/">https://www.cpolar.com</a><br>使用一键脚本安装命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> curl https://get.cpolar.sh | sh</span><br></pre></td></tr></table></figure><br>安装完成后，执行下方命令查看cpolar服务状态：（如图所示即为正常启动）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status cpolar</span><br></pre></td></tr></table></figure><br>Cpolar安装和成功启动服务后，在浏览器上输入虚拟机主机IP（打开 WebDev 时显示的 IP）加9200端口。</p><p>例如：<code>http://192.168.5.24:9200</code>，访问Cpolar管理界面，使用Cpolar官网注册的账号登录,登录后即可看到cpolar web 配置界面,接下来在web 界面配置即可。</p><p>打开浏览器访问本地9200端口，使用cpolar账户密码登录即可,登录后即可对隧道进行管理。<br><img src="assets/file-20251121160152844.png" alt=""></p><h3 id="配置公网地址"><a href="#配置公网地址" class="headerlink" title="配置公网地址"></a>配置公网地址</h3><p>通过配置，你可以在本地 WSL 或 Linux 系统上运行 SSH 服务，并通过 Cpolar 将其映射到公网，从而实现从任意设备远程连接开发环境的目的。</p><ul><li>隧道名称：可自定义，本例使用 obsidian，注意不要与已有的隧道名称重复</li><li>协议：http</li><li>本地地址：192.168.5.24:5005</li><li>域名类型：随机域名（其他需要收费，所以有的时候域名会变就要自己更改了）</li><li>地区：China Top</li></ul><p><img src="/assets/file-20251121160600915.png" alt="alt text"><br>创建成功后，打开左侧在线隧道列表,可以看到刚刚通过创建隧道生成了公网地址，接下来就可以在其他电脑或者移动端设备（异地）上，使用任意一个地址在终端中访问即可。</p><ul><li>Http 表示使用的协议类型</li><li><code>http://788cb346.r29.cpolar.top</code> 是 Cpolar 提供的域名</li></ul><p><img src="/assets/file-20251121160757795.png" alt="alt text"></p><h3 id="打开-Obsidian-的-Remotely-Save-插件（踩坑）"><a href="#打开-Obsidian-的-Remotely-Save-插件（踩坑）" class="headerlink" title="打开 Obsidian 的 Remotely Save 插件（踩坑）"></a>打开 Obsidian 的 Remotely Save 插件（踩坑）</h3><p>打开 Obsidian 的 Remotely Save 插件开始同步<br><img src="/assets/file-20251121161245775.png" alt="alt text"><br><strong>问题</strong>：如果将隧道地址填写进服务器地址进行检查的时候显示连接不上这个服务器。<br><strong>解决</strong>：必须在隧道地址后面添加 NAS 极空间的目录地址(比如:<code>http://xxx/public/Public/docker/cpolar</code>)，此时检查才能通过<br><img src="/assets/file-20251121161509981.png" alt="alt text"></p><h3 id="缺陷——域名更新"><a href="#缺陷——域名更新" class="headerlink" title="缺陷——域名更新"></a>缺陷——域名更新</h3><p>因为 Cpolar 的域名固定都是需要花钱的，所以免费的就只能自己更新域名了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;试错-Tailscale-多端同步&quot;&gt;&lt;a href=&quot;#试错-Tailscale-多端同步&quot; class=&quot;headerlink&quot; title=&quot;试错 Tailscale 多端同步&quot;&gt;&lt;/a&gt;试错 Tailscale 多端同步&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a h</summary>
      
    
    
    
    
    <category term="Obsidian" scheme="https://ssfortynine.github.io/blog/tags/Obsidian/"/>
    
  </entry>
  
  <entry>
    <title>芯动力——硬件加速设计方法</title>
    <link href="https://ssfortynine.github.io/blog/2024/07/25/HardwareDesign1/"/>
    <id>https://ssfortynine.github.io/blog/2024/07/25/HardwareDesign1/</id>
    <published>2024-07-24T19:51:43.000Z</published>
    <updated>2025-11-22T08:13:59.952Z</updated>
    
    <content type="html"><![CDATA[<p>硬件加速设计方法：专题一 高质量VerilogHDL描述方法</p><h2 id="VerilogHDL-可综合描述"><a href="#VerilogHDL-可综合描述" class="headerlink" title="VerilogHDL 可综合描述"></a>VerilogHDL 可综合描述</h2><p>VerilogHDL 是描述可综合的硬件电路<br>HDL 语言具有以下的硬件设计的基本概念</p><ul><li><strong>互联 (connectivity)</strong> - wire 型变量描述各个模块之间的端口和网线连接关系</li><li><strong>并发 (concurrency) </strong>- 可以有效地描述并行的硬件系统</li><li><strong>时间 (time) </strong>- 定义了绝对和相对的时间度量，可综合操作符都是具有物理延时的</li></ul><h2 id="Verilog-HDL-用于可综合描述的语句"><a href="#Verilog-HDL-用于可综合描述的语句" class="headerlink" title="Verilog HDL 用于可综合描述的语句"></a>Verilog HDL 用于可综合描述的语句</h2><h3 id="可用于综合的语句"><a href="#可用于综合的语句" class="headerlink" title="可用于综合的语句"></a>可用于综合的语句</h3><p><strong>always</strong><br><strong>if-else</strong>: 映射的硬件结构-多路选择器，输出结果由输入的选择确定</p><ul><li>代码和电路是互相等价的。<strong>硬件结构比较复杂，以及控制通道的延迟</strong>等。代码在书写的时候就要注意<strong>综合电路的性能最优化</strong>，要综合考虑硬件电路的性能和结构。</li><li>要根据输入约束，小心设计：<strong>先”加”后“选”</strong>，还是<strong>先”选”后“加”</strong></li><li><strong>单 if 语句</strong>：无优先级的判断结构，描述多条件判断结构</li><li><strong>多 if 语句</strong>：有优先级的判断结构，<strong>最后一级信号具有最高优先级，具有优先级的多选结构会消耗组合逻辑</strong>。若某些设计中，有些信号要求先到达（如<strong>关键使能信号、选择信号</strong>等），有些信号要求后到达（如<strong>慢速信号、有效时间较长的信号</strong>等），此时需要使用 if..if 语句。设计方法：最高优先级给最迟到达的关键信号<br><strong>case</strong>：无优先级的判断结构，与单 if 语句的区别是条件互斥，通常用于指令编码译码电路<br><strong>assign</strong></li></ul><h3 id="不可用于综合的语句"><a href="#不可用于综合的语句" class="headerlink" title="不可用于综合的语句"></a>不可用于综合的语句</h3><p><strong>function</strong>、<strong>for </strong>、<strong>fork-join</strong>、<strong>while</strong></p><h3 id="Latch和D触发器"><a href="#Latch和D触发器" class="headerlink" title="Latch和D触发器"></a>Latch和D触发器</h3><p>一般情况下避免使用 latch (锁存器)，一般只有在异步电路和门控时钟时会用到 latch<br><img src="/assets/Pastedimage20231024202936.png" alt=""><br>latch 是电平触发，非同步控制。DFF 由时钟沿触发，同步控制。Latch 容易产生毛刺（glitch），而 DFF 不易产生毛刺。<br>latch 将 STA 变得复杂。因为 Latch 不能过滤毛刺，对下一级电路极其危险，所以避免产生 Latch, 尽可能使用 D 触发器</p><h3 id="避免产生-Latch-的措施"><a href="#避免产生-Latch-的措施" class="headerlink" title="避免产生 Latch 的措施"></a>避免产生 Latch 的措施</h3><p>易引入 latch 的途径：使用不完备的条件判断语句（if-else 语句缺少 else、case 语句缺少 default）</p><blockquote><p>防止产生 latch 的措施</p><ol><li>使用完备的 if… Else 语句</li><li>为每个输入条件设计输出操作，为 case 语句设置 default 操作</li><li>仔细检查综合器生成的报告，latch 会以 warning 的形式报告</li></ol></blockquote><h3 id="full-case-和-parallel-case-综合器指令"><a href="#full-case-和-parallel-case-综合器指令" class="headerlink" title="full-case 和 parallel-case 综合器指令"></a>full-case 和 parallel-case 综合器指令</h3><p>有时会出现设计目标缘故产生 Latch<br><code>full-case</code>: 告诉综合器，当前 case 结构所列条件已完备(<code>//synopsys full_case</code>)<br><code>parallel-case</code>: 告诉 DC，所有条件均互斥，且并行，无优先权(<code>//synopsys parallel_case</code>)</p><p><strong>逻辑复制-&gt;均衡负载</strong><br>通过逻辑复制，降低关键信号的扇出，进而降低该信号的传播延迟，提高电路性能</p><p><strong>资源共享-&gt;减小面积</strong><br>一般进行资源共享会减小电路面积，但是性能会下降，要综合考虑性能和面积而进行取舍</p><p><strong>资源顺序重排-&gt;降低传播延时</strong><br>如果一个输入信号来的晚我们可以尽可能的把它放在后面，隐藏其延迟</p><p><strong>assign 仅用来连线，always 用于逻辑运算</strong><br>尽量少用 assign 进行逻辑运算，不仅难以阅读，且多层嵌套之后很难被综合器解释(不过现在好像更多用是<code>assign</code>来描述逻辑电路)</p><h3 id="可综合风格"><a href="#可综合风格" class="headerlink" title="可综合风格"></a>可综合风格</h3><p><strong>完整的 <code>always</code>  敏感信号列表</strong><br>敏感信号列表必须包含输入信号</p><ul><li>原因：综合过程中会产生一个取决于除敏感列表中所有其他值的结构，它将可能在行为仿真和门级仿真间产生潜在的失配</li></ul><p><strong>每个 <code>always</code> 敏感信号列表只能对应一个时钟</strong></p><ul><li>将每个过程限制在单一寄存器中，有利于 STA 和逻辑综合</li></ul><p><strong>不允许 <code>wait</code> 声明和 <code>#delay</code> 声明</strong>  </p><ul><li>综合器不允许，但是可以在测试模块和表示行为的虚拟模块中使用<blockquote><p>语法说明<br>在时序电路中必须使用非阻塞赋值 <code>&lt;=</code><br>在组合逻辑电路中必须使用阻塞赋值 <code>=</code></p></blockquote></li></ul><h3 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h3><p><strong>分开异步逻辑和同步逻辑</strong></p><ul><li>原因：避免综合时的问题，简化约束和编码难度。</li><li>例外：不可应用于非综合模块中（例如：总线模块、总线监视器或是模拟模块）除非他们被设计来综合仿真</li></ul><p><strong>分开控制逻辑和存储器模块</strong></p><ul><li>通常来说，存储器都是用 memory complier 来生成的，其综合方式和 RTL 代码不同，混合在一起不利于综合，不利于很方便地更换工艺库和平台</li></ul><h3 id="在-RTL-书写中如何考虑延迟、面积等"><a href="#在-RTL-书写中如何考虑延迟、面积等" class="headerlink" title="在 RTL 书写中如何考虑延迟、面积等"></a>在 RTL 书写中如何考虑延迟、面积等</h3><p><strong>在 RTL 代码中考虑时</strong></p><ul><li>针对控制信号来到比较晚，尽可能<strong>将延时较大的分支单独拿出来，放在出口最近的选择器中</strong></li><li>注意<strong>“先加后选”</strong>和<strong>“先选后加”</strong></li><li><strong>加法器、乘法器等复杂的器件少用</strong></li><li>减少设计面积：首先要估计使用设计资源的数量，比如使用了多少触发器、加法器、乘法器。可以借助工具，<strong>最终应该知道在设计中哪些部分占了较大的面积，进而分析和改进</strong></li><li>一般来说触发器由功能决定，很难减少，只能从组合逻辑出发。对于 RTL 代码，就是各种操作符，应该了解<strong>各种操作符对应的电路</strong>，如使用<strong>“+”、”-“、”x”、”/“</strong>以及一些条件语句中的比较运算，对于这些操作，<strong>首先判断其必要性，是否能用更简单的方法解决</strong></li><li>如果必须使用复杂的运算符，应考虑<strong>资源共享</strong>，从代码出发，而不是只依靠综合器</li><li>多比特的信号也会占用大量的资源，针对不同的设计有不同的改进方法，对于有可能简化的地方尽可能简化，<u>逻辑简化的同时也对应面积减少和时延减少</u></li></ul><p><strong>对于功耗控制</strong></p><ul><li><strong>门控时钟</strong>，时钟电路的翻转消耗大量资源，此时可以使用门控时钟，减少时钟电路的翻转</li><li><strong>增加使能信号</strong>，使得部分电路只有工作的时候才工作，与门控时钟的差别在与，使用使能信号只使得被控制的电路不再工作，但是其时钟仍然在工作，而门控时钟是使时钟停止工作</li><li><strong>对芯片各个模块进行控制，只有工作的时候才使用</strong></li><li>除了有用信号和时钟的翻转会消耗功耗，组合逻辑的毛刺也会大量消耗功耗，但是在设计过程中毛刺是不可避免的，但是要尽量<strong>减少毛刺的传播</strong>，才可以减少功耗。</li><li>有限状态机，通过<strong>低功耗编码</strong>来减少电路的翻转，比如独热码</li><li>在 RTL 编码阶段对布局布线进行考虑，避免无法布通的情况。<u>如果采用大的 mux，可以将其分解为多级较小的 mux。</u></li></ul><h2 id="RTL-设计指导规则"><a href="#RTL-设计指导规则" class="headerlink" title="RTL 设计指导规则"></a>RTL 设计指导规则</h2><ul><li>RTL 级的设计评判标准很多，如<strong>时序性能、所占面积、可测试性、可重用性、功耗、时钟域的分配、复位信号设计以及与所用 EDA 工具匹配等</strong>。</li><li>一般的指导原则：面积与速度互换、乒乓操作、流水线设计</li></ul><h3 id="面积与速度互换"><a href="#面积与速度互换" class="headerlink" title="面积与速度互换"></a>面积与速度互换</h3><p>面积：一个设计所消耗的目标器件的<strong>硬件资源数量</strong>或者 <strong>ASIC 芯片面积</strong></p><ul><li>FPGA 可以用所消耗的<strong>触发器CFF</strong> 和<strong>查找表数量</strong>来衡量<br>速度：设计在芯片上稳定运行时所能达到的最高频率，这个频率一般由设计的时序状况来决定</li><li>时序特征向量：<strong>时钟周期，PAD to PAD time，Clock setup time, Clock hold time, Clock-to-Output Delay</strong><br>科学的设计目标：</li><li><u>在满足设计时序的要求（包含对设计的最高频率要求）的前提下，占用最小的芯片面积。</u></li><li><u>在所规定的面积下，使设计的时序余量更大，频率更高。</u></li><li>如果设计的时序余量更大，频率更高——设计的健壮性更强, 整个系统的设计质量更有保证</li><li>设计所消耗的面积小——在单位芯片上实现的功能更多，需要的芯片数量更少，成本更低</li><li>满足时序和工作频率的要求更高，即速度优先<br><img src=/assets/Pastedimage20231025195027.png width=80% /></li></ul><blockquote><p>速度与面积互换</p><ol><li>如果时序余量大，速度-&gt;面积<ul><li>模块复用</li></ul></li><li>如果一个设计时序要求高，普通方法达不到设计频率<ul><li>数据流串并转换</li><li>并行复制多个操作模块</li><li>“乒乓操作”和“串并转换”</li><li>在芯片模块输出处在对数据进行“并串转换”</li></ul></li></ol></blockquote><h3 id="乒乓操作"><a href="#乒乓操作" class="headerlink" title="乒乓操作"></a>乒乓操作</h3><ul><li>乒乓操作一个常常用于数据流控制的处理方法<br><img src=/assets/Pastedimage20231025195210.png width=80% /></li><li><strong>节约缓冲区</strong></li><li><strong>巧妙运用乒乓操作可以做到低速模块处理高速数据流的效果</strong></li></ul><h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><ul><li><p>电路的最高频率取决于最长的组合逻辑链路的延迟值<br><img src=/assets/Pastedimage20231025200113.png width=80% /></p></li><li><p>流水线当方法可以有效提高系统的工作频率，但是考虑一个电路的性能通常都是<strong>其单位时间的计算量，或者是一定计算总量下的处理时间</strong><br><img src=/assets/Pastedimage20231025200349.png width=80% /></p></li></ul><p><strong>特点</strong></p><ul><li>通过<strong>插入寄存器</strong>，将长的串行逻辑链分成较小的部分</li><li>当系统运算是串行时，利用时钟控制，使运算依照顺序接续执行</li><li>在任何制定时刻，大部分电路都在运行</li></ul><p><strong>好处</strong></p><ul><li><strong>每一部分延时更小-&gt;可使用更快的时钟</strong></li><li><strong>大部分电路同时进行计算-&gt;可提高数据通过量（吞吐量）</strong></li></ul><p><strong>流水线参数设计</strong></p><ul><li>系统时钟取决于最慢的流水线级的延时<ul><li>流水线时钟周期：<script type="math/tex; mode=display">T_{pipe} = max{T_1,T_2,...,T_m}</script></li><li>第 i 级的时钟周期：<script type="math/tex; mode=display">T_i>t_ff+...+t_{su}+t_{d,i}+t_{s,i}+1</script></li></ul></li><li>流水线分割点及参数确定要考虑的因素<ul><li><strong>单位延迟时间及时间频率的大小决定了数据通过速率</strong></li><li><strong>过多的级数不一定能产生最快的结果</strong></li><li><strong>太多的寄存器的插入会导致芯片面积的增加，布线困难，时钟偏差增加</strong></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;硬件加速设计方法：专题一 高质量VerilogHDL描述方法&lt;/p&gt;
&lt;h2 id=&quot;VerilogHDL-可综合描述&quot;&gt;&lt;a href=&quot;#VerilogHDL-可综合描述&quot; class=&quot;headerlink&quot; title=&quot;VerilogHDL 可综合描述&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
    <category term="FPGA" scheme="https://ssfortynine.github.io/blog/tags/FPGA/"/>
    
  </entry>
  
  <entry>
    <title>Zerotier-Archlinux-Termius互通教程</title>
    <link href="https://ssfortynine.github.io/blog/2024/07/24/Zerotier/"/>
    <id>https://ssfortynine.github.io/blog/2024/07/24/Zerotier/</id>
    <published>2024-07-24T06:23:09.000Z</published>
    <updated>2024-09-29T14:25:59.821Z</updated>
    
    <content type="html"><![CDATA[<p>使用Zerotier 和Termius 通过SSH创建个人PC服务器,并且用ipad连接Archlinux</p><h2 id="Zerotier的配置和使用"><a href="#Zerotier的配置和使用" class="headerlink" title="Zerotier的配置和使用"></a>Zerotier的配置和使用</h2><p>Zerotier 是一款不需要公网 IP 内网穿透软件，<code>ZeroTier</code> 是一个专门用来建立点对点虚拟专用网（<code>P2P VPN</code>）的工具，它提供在线管理界面和全平台的客户端，不需要复杂设置，只要安装客户端并加入到自己创建的网络即可。</p><blockquote><ol><li><p>官方网站地址：<a href="https://www.zerotier.com/">https://www.zerotier.com</a></p></li><li><p>项目地址：<a href="https://github.com/zerotier">https://github.com/zerotier</a></p></li></ol></blockquote><h2 id="注册和客户端安装"><a href="#注册和客户端安装" class="headerlink" title="注册和客户端安装"></a>注册和客户端安装</h2><h3 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h3><p>ZeroTier 可以通过邮箱或者 <code>Google</code> <code>Github</code> <code>Microsoft</code> 账号注册。</p><p><img src="/assets/Pastedimage20240310163135.png" alt=""></p><p>进入 Zerotier 之后就可以创建你的 Networks。<code>NETWORK ID</code> 是客户端连接到行星服务器的唯一识别码，需要牢记, 即每个客户端需要 Join 的 ID, <code>NAME</code> 可以随意更改。</p><p><img src="/assets/Pastedimage20240310163523.png" alt=""></p><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p><code>SUBNET</code> 是 <code>Zerotier One</code> 使用 <code>STUN</code> 和隧道建立的 <code>NAT</code>，可以更改内网 ip 网段。<code>NODES</code> 是连入 <code>NETWORK</code> 的设备数，以及建立时间 <code>CREATED</code>。</p><p><img src="/assets/Pastedimage20240310164241.png" alt=""></p><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p><code>ZeroTier</code> 支持 <code>Windows</code>、<code>macOS</code>、<code>Linux</code> 三大桌面平台，<code>iOS</code>、<code>Android</code> 两大移动平台，<code>QNAP（威连通）</code>、<code>Synology（群晖）</code>、<code>Western Digital MyCloud NAS（西部数据）</code> 三个 <code>NAS</code> 平台，还支持 <code>OpenWrt/LEDE</code> 开源路由器项目。</p><blockquote><p>下载地址：<a href="https://www.zerotier.com/download/">https://www.zerotier.com/download/</a></p></blockquote><p>这里以 <code>Ipad</code> 、<code>Andriod</code>、<code>Archlinux</code> 设备为例介绍一下客户端如何与 <code>planet</code> 相连接挂载到内网地址。</p><p><code>ios</code> 设备通过 <code>Appstore</code> 下载，<code>Andriod</code> 设备通过下载地址下载即可。<code>Network ID</code>，配置好 <code>VPN</code> 后就会启动连接。</p><p><code>SUBNET</code> 是 <code>Zerotier One</code> 使用 <code>STUN</code> 和隧道建立的 <code>NAT</code>，可以更改内网 ip 网段。<code>NODES</code> 是连入 <code>NETWORK</code> 的设备数，以及建立时间 <code>CREATED</code>。</p><p><img src="/assets/IMG20240310165324.jpg" alt=""></p><p><img src="/assets/IMG20240310165251.jpg" alt=""></p><p><code>Android</code> 使用方法同理。</p><p><img src=/assets/Screenshot20240310165506.jpg width=60% /></p><p><img src=/assets/Screenshot20240310165517.jpg width=60% /></p><p><code>Archlinux</code> 在 <code>Termial</code> 中使用命令行下载和启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装zerotier-one</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> pacman -S zerotier-one</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启和加入开机自启</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl start zerotier-one.service</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl <span class="built_in">enable</span> zerotier-one.service</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加入、离开、列出网络</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> zerotier-cli <span class="built_in">join</span> [此处<span class="built_in">id</span>]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> zerotier-cli leave</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> zerotier-cli listnetworks</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取地址和服务状态</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> zerotier-cli status</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>这时会根据 <code>MAC</code> 地址分配给设备一个唯一认证字符串 <code>Node ID</code>，可用来在 <code>Web</code> 配置界面保留该设备不被删除以及帮助我们区分设备。我们在 <code>Auth?</code> 处勾上就可以让设备连接到 <code>planet</code> 中。</p><p><img src="/assets/Pastedimage20240310170348.png" alt=""></p><h2 id="Ipad-SSH"><a href="#Ipad-SSH" class="headerlink" title="Ipad SSH"></a>Ipad SSH</h2><p>理论上来说在同一个局域网下 <code>ssh</code> 可以通过设备的 <code>IP</code> 地址来连接，此时我们通过 <code>Zerotier</code> 使不同局域网下的设备处于统一 <code>Networks</code> 下，只要 <code>ssh Managed IP</code> 即可完成设备间的互访。</p><h3 id="Termius"><a href="#Termius" class="headerlink" title="Termius"></a>Termius</h3><p><code>Termius</code> 是一个非常好用的 <code>SSH</code> 客户端，免费版就已经提供了 <code>SSH</code> 功能，满足我们连接并操作 <code>Archlinux</code> 的需求。<code>IOS</code> 通过 <code>appstore</code> 下载，<code>Andriod</code> 通过 <code>google play</code> 商店下载，这里以 <code>ipad</code> 设备为例对 <code>archlinux</code> 设备进行访问。在 termius 的设置中要输入连接名称 alias (随便取)、IP 地址（这里你要访问设备的 Managed IP 地址，在 Zerotier 配置页面）、SSH 端口号、用户名与密码。</p><p><img src="/assets/IMG20240310172148.jpg" alt=""></p><p><img src=/assets/IMG20240310171845.jpg width=60% /></p><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>Archlinux 需要设置 SSH 服务，下载配置命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载SSH</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> pacman -S openssh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行Open SSH</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl start sshd</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Open SSH状态</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl status sshd</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">终止SSH服务器</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl stop sshd</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">系统重新启动时自动启动 SSH 服务器</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> sshd</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从系统启动中删除</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> sshd</span></span><br></pre></td></tr></table></figure><p>下载配置启动 SSH 之后我们要对 SSH 配置文件中修改一些选项，以方便 ipad 或者其他设备可以连接到 linux服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> nvim /etc/ssh/sshd_config</span> </span><br></pre></td></tr></table></figure><p>我们可以在这个配置文件中修改我们的 SSH 端口，默认是 22。以及 Authentication 的状态，将 <code>PermitRootLogin</code> 设置为 <code>yes</code> 并且取消注释，就可以让访问设备打开 ROOT 权限。通过 <code>PubkeyAuthentication</code> 设置为 <code>yes</code> 那么只能允许服务器承认的 key 可以连接。修改完配置文件使用 <code>sudo systemctl restart sshd</code> 重新打开 ssh。</p><p><img src=/assets/Pastedimage20240310173333.png width=40% /></p><p><img src=/assets/Pastedimage20240310173420.png width=40% /></p><p><img src=/assets/Pastedimage20240310173550.png width=100% /></p><h3 id="测试设备间互访"><a href="#测试设备间互访" class="headerlink" title="测试设备间互访"></a>测试设备间互访</h3><p>不同网络访问：<code>Archlinux</code> 连接 <code>5g</code> 网络，<code>iPad</code> 连接 <code>wifi</code>。</p><p><img src="/assets/IMG20240310174149.jpg" alt=""></p><p>从图中我们可以看到已经成功连接上了 <code>Archlinux</code> 的 <code>SSH</code>。由于免费的根服务器在国外，可能访问速度不太稳定。 </p><h2 id="笔记本不休眠"><a href="#笔记本不休眠" class="headerlink" title="笔记本不休眠"></a>笔记本不休眠</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> nvim /etc/systemd/logind.conf</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将其中</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HandleLidSwitch=<span class="built_in">suspend</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">去掉前面的#改成</span></span><br><span class="line">HandleLidSwitch=ignore</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最后重启服务</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用Zerotier 和Termius 通过SSH创建个人PC服务器,并且用ipad连接Archlinux&lt;/p&gt;
&lt;h2 id=&quot;Zerotier的配置和使用&quot;&gt;&lt;a href=&quot;#Zerotier的配置和使用&quot; class=&quot;headerlink&quot; title=&quot;Zer</summary>
      
    
    
    
    
    <category term="Tool" scheme="https://ssfortynine.github.io/blog/tags/Tool/"/>
    
  </entry>
  
</feed>
